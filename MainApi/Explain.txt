این پروژه یک پلتفرم فروشگاهی پیشرفته است که با استفاده از جدیدترین تکنولوژی‌های .NET و با پیروی از اصول معماری نرم‌افزار مدرن (مانند معماری پیاز یا Clean Architecture) طراحی شده است. هدف اصلی این معماری، جداسازی مسئولیت‌ها، افزایش قابلیت نگهداری و توسعه‌پذیری سیستم است.

پروژه به چهار لایه اصلی تقسیم شده است:

Domain (هسته کسب‌وکار): قلب تپنده سیستم که قوانین و موجودیت‌های اصلی کسب‌وکار در آن تعریف شده‌اند.
Application (لایه منطق برنامه): مسئول هماهنگی و اجرای فرآیندهای کسب‌وکار.
Infrastructure (لایه زیرساخت): پیاده‌سازی جزئیات فنی مانند ارتباط با دیتابیس، سرویس‌های خارجی و کش.
MainApi (لایه نمایش): نقطه ورود به سیستم از طریق API که درخواست‌های کاربران را مدیریت می‌کند.
در ادامه، عملکرد هر بخش به تفصیل شرح داده می‌شود.

۱. مدیریت کاربران و احراز هویت (Authentication & User Management)
این بخش مسئولیت ثبت‌نام، ورود، مدیریت پروفایل و آدرس‌های کاربران را بر عهده دارد.

ورود بدون رمز عبور (Password-less Login):

کاربر شماره موبایل خود را در UsersController وارد می‌کند.
UserService یک کد یکبار مصرف (OTP) امن تولید کرده و آن را به صورت هش‌شده در دیتابیس (جدول UserOtp) ذخیره می‌کند.
پس از تأیید کد توسط کاربر، UserService یک توکن JWT (JSON Web Token) و یک Refresh Token تولید می‌کند. توکن JWT برای دسترسی به APIها استفاده می‌شود و Refresh Token برای تمدید نشست کاربر بدون نیاز به ورود مجدد.
اطلاعات نشست کاربر (Session) در جدول UserSession ذخیره می‌شود تا امکان مدیریت و ابطال نشست‌ها فراهم باشد.
مدیریت پروفایل و آدرس:

ProfileController به کاربران اجازه می‌دهد اطلاعات خود (نام، نام‌خانوادگی) و آدرس‌های پستی خود را مدیریت کنند.
هر کاربر می‌تواند چندین آدرس داشته باشد که در جدول UserAddress ذخیره می‌شوند.
سطوح دسترسی (Admin & User):

سیستم دارای دو سطح دسترسی اصلی است: کاربر عادی و مدیر (Admin).
با استفاده از Authorize Attribute در کنترلرها (مانند [Authorize(Roles = "Admin")])، دسترسی به APIهای حساس فقط برای مدیران امکان‌پذیر است. CurrentUserService مسئول تشخیص نقش کاربر فعلی است.
۲. مدیریت محصولات، دسته‌بندی‌ها و انبار (Product, Category & Inventory)
این بخش شامل تمام فرآیندهای مربوط به تعریف محصول، دسته‌بندی، مدیریت موجودی و قیمت‌گذاری است.

دسته‌بندی دو سطحی (Category & CategoryGroup):

محصولات در یک ساختار دو سطحی سازماندهی می‌شوند: Category (مانند کالای دیجیتال) و CategoryGroup (مانند موبایل). این کار انعطاف‌پذیری بالایی برای مدیریت محصولات فراهم می‌کند.
CategoryController و CategoryGroupController وظیفه مدیریت این دسته‌بندی‌ها را بر عهده دارند.
محصولات با ویژگی‌های متغیر (Product Variants):

یک Product می‌تواند چندین ProductVariant داشته باشد (مانند یک مدل تیشرت با رنگ‌ها و سایزهای مختلف).
هر ProductVariant می‌تواند قیمت، موجودی، SKU و ویژگی‌های (Attributes) منحصربه‌فرد خود را داشته باشد. این ویژگی‌ها در جداول AttributeType و AttributeValue تعریف می‌شوند (مثلاً AttributeType "رنگ" و AttributeValue "قرمز").
ProductService منطق پیچیده ایجاد و به‌روزرسانی محصولات و انواع آن‌ها را مدیریت می‌کند.
مدیریت انبار (Inventory):

InventoryService تمام تراکنش‌های مربوط به موجودی کالا را ثبت می‌کند. هرگونه تغییر در موجودی (فروش، مرجوعی، افزایش موجودی دستی) به عنوان یک InventoryTransaction در دیتابیس ثبت می‌شود.
این سرویس از قفل‌گذاری خوشبینانه (Optimistic Concurrency) با استفاده از RowVersion پشتیبانی می‌کند تا از تداخل در هنگام تغییر همزمان موجودی جلوگیری شود.
جستجوی پیشرفته محصولات:

ProductService قابلیت جستجوی پیشرفته بر اساس نام، محدوده قیمت، دسته‌بندی، وضعیت موجودی و تخفیف را با استفاده از ProductSearchDto فراهم می‌کند.
۳. سبد خرید (Shopping Cart)
سیستم سبد خرید هم برای کاربران وارد شده و هم برای کاربران مهمان (Guest) کار می‌کند.

عملکرد دوگانه (کاربر و مهمان):

CartService با استفاده از UserId برای کاربران عضو و GuestToken (که در هدر X-Guest-Token ارسال می‌شود) برای کاربران مهمان، سبد خرید را شناسایی می‌کند.
CartsController نقطه ورود برای تمام عملیات سبد خرید است.
ادغام سبد خرید (Merge Cart):

هنگامی که یک کاربر مهمان وارد حساب کاربری خود می‌شود، UserService متد MergeCartAsync از CartService را فراخوانی می‌کند. این متد، آیتم‌های سبد خرید مهمان را به سبد خرید اصلی کاربر منتقل می‌کند تا تجربه کاربری یکپارچه‌ای ایجاد شود.
کشینگ هوشمند:

اطلاعات سبد خرید برای افزایش سرعت در Redis (یا حافظه داخلی) کش می‌شود. هرگونه تغییر در محصول یا موجودی آن، باعث ابطال کش سبدهای خرید مرتبط می‌شود تا اطلاعات همیشه به‌روز باقی بماند.
۴. فرآیند سفارش و پرداخت (Order & Payment)
این بخش مسئولیت ثبت نهایی سفارش، اعمال تخفیف، اتصال به درگاه پرداخت و پردازش نتیجه آن را بر عهده دارد.

ثبت سفارش از سبد خرید:

OrdersController متد CheckoutFromCartAsync را برای شروع فرآیند پرداخت فراخوانی می‌کند.
OrderService یک سفارش با وضعیت "در انتظار پرداخت" ایجاد کرده و موجودی انبار را به صورت موقت کاهش می‌دهد.
این فرآیند از Idempotency-Key در هدر درخواست پشتیبانی می‌کند تا از ثبت سفارش تکراری در صورت ارسال چندباره یک درخواست جلوگیری شود.
یکپارچه‌سازی با درگاه پرداخت (Zarinpal):

ZarinpalService مسئولیت ارتباط با وب‌سرویس‌های زرین‌پال برای ایجاد درخواست پرداخت و تأیید آن را بر عهده دارد.
پس از ایجاد سفارش، OrderService یک لینک پرداخت از ZarinpalService دریافت کرده و برای کاربر ارسال می‌کند.
کاربر پس از پرداخت، به یک callbackUrl بازگردانده می‌شود. OrdersController درخواست را دریافت کرده و متد VerifyAndProcessPaymentAsync را برای تأیید نهایی پرداخت فراخوانی می‌کند.
در صورت موفقیت، وضعیت سفارش به "در حال پردازش" تغییر کرده و یک PaymentTransaction ثبت می‌شود.
مدیریت تخفیف‌ها:

DiscountService وظیفه اعتبارسنجی کدهای تخفیف را بر عهده دارد. این سرویس مواردی مانند تاریخ انقضا، محدودیت استفاده، حداقل مبلغ سفارش و اختصاصی بودن کد برای یک کاربر خاص را بررسی می‌کند.
۵. زیرساخت و سرویس‌های عمومی (Infrastructure)
این لایه شامل پیاده‌سازی‌های فنی و ابزارهای مشترک است.

دسترسی به داده (Persistence):

استفاده از Entity Framework Core به عنوان ORM برای ارتباط با دیتابیس PostgreSQL.
الگوی Repository برای جداسازی منطق دسترسی به داده‌ها از منطق کسب‌وکار (مثال: ProductRepository).
الگوی Unit of Work (IUnitOfWork) برای تضمین تمامیت داده‌ها در عملیات چندمرحله‌ای (همه تغییرات با هم ثبت می‌شوند یا هیچ‌کدام ثبت نمی‌شوند).
کشینگ (Caching):

ICacheService یک اینترفیس مشترک برای عملیات کش است.
RedisCacheService پیاده‌سازی این اینترفیس با استفاده از Redis است که عملکرد بسیار بالایی دارد و قابلیت کشینگ توزیع‌شده را فراهم می‌کند.
در صورت عدم دسترسی به Redis، سیستم به صورت خودکار به InMemoryCacheService سوئیچ می‌کند تا برنامه بدون وقفه به کار خود ادامه دهد.
سرویس ذخیره‌سازی فایل (Storage):

IStorageService برای آپلود و مدیریت فایل‌ها (مانند تصاویر محصولات) استفاده می‌شود.
LiaraStorageService این اینترفیس را با استفاده از سرویس ذخیره‌سازی ابری لیارا پیاده‌سازی می‌کند.
لاگینگ و مانیتورینگ (Logging & Auditing):

Serilog: برای ثبت لاگ‌های برنامه با جزئیات کامل در فایل و کنسول استفاده می‌شود.
AuditService: تمام رویدادهای مهم امنیتی، کاربری و سیستمی (مانند ورود موفق، تغییر در سفارش، پاک شدن سبد خرید) را در جدول AuditLog ثبت می‌کند تا قابلیت ردیابی کامل وجود داشته باشد.
امنیت:

SecurityHeadersMiddleware: مجموعه‌ای از هدرهای امنیتی HTTP (مانند CSP, HSTS, X-Frame-Options) را به پاسخ‌ها اضافه می‌کند تا از حملات متداول وب (مانند XSS, Clickjacking) جلوگیری شود.
RateLimitService: برای جلوگیری از حملات Brute-force و DoS، تعداد درخواست‌های کاربران (چه مهمان و چه عضو) را بر اساس IP یا UserId محدود می‌کند.
CSRF Protection: با استفاده از Antiforgery Token، از حملات Cross-Site Request Forgery محافظت می‌کند.

=======================================================
=======================================================
=======================================================
=======================================================
=======================================================

تحلیل فنی جامع: از ویترین تا پنل مدیریت
این گزارش به دو بخش اصلی تقسیم می‌شود:

بخش اول: سفر مشتری (Customer Journey) - ردیابی فنی جریان کار از لحظه مشاهده محصول تا تکمیل سفارش.
بخش دوم: پنل مدیریت (Admin Panel) - تشریح قابلیت‌ها و فرآیندهای در دسترس مدیران سیستم.
بخش اول: سفر مشتری (از نمایش تا خرید)
در این بخش، مسیر یک کاربر (چه مهمان و چه عضو) را از ابتدا تا انتها به صورت فنی دنبال می‌کنیم.

۱. نمایش محصولات و دسته‌بندی‌ها (Product & Category Display)
این فرآیند، نقطه شروع تعامل کاربر با فروشگاه است و باید سریع، بهینه و دقیق باشد.

نقطه ورود (API Endpoint):

دسته‌بندی‌ها: GET /api/category در CategoryController. این متد به صورت عمومی (AllowAnonymous) قابل دسترسی است.
محصولات: GET /api/products در ProductsController. این متد نیز عمومی است.
جریان فنی نمایش دسته‌بندی:

درخواست به CategoryController می‌رسد.
کنترلر، متد GetCategoriesAsync از ICategoryService را فراخوانی می‌کند.
CategoryService با استفاده از ICategoryRepository، لیست دسته‌بندی‌ها (Category) را به همراه زیرمجموعه‌هایشان (CategoryGroup) از دیتابیس واکشی می‌کند.
برای هر دسته‌بندی و زیرمجموعه، IMediaService فراخوانی می‌شود تا URL تصویر اصلی (IconUrl) را از LiaraStorageService دریافت کند.
داده‌ها به CategoryViewDto و CategoryGroupSummaryDto مپ شده و به کاربر بازگردانده می‌شود. این DTOها فقط شامل اطلاعات ضروری برای نمایش هستند (مانند تعداد محصولات، موجودی و...).
جریان فنی نمایش محصولات (جستجو و لیست):

کاربر درخواستی به GET /api/products با پارامترهای جستجو (مانند نام، دسته‌بندی، محدوده قیمت) که در ProductSearchDto قرار دارند، ارسال می‌کند.
ProductsController این درخواست را به GetProductsAsync در IProductService ارسال می‌کند.
ProductService با کمک ProductRepository یک کوئری بهینه به دیتابیس می‌زند.
فیلترها: تمام شروط جستجو (ApplyProductFilters) روی کوئری اعمال می‌شود (مانند WHERE p.Name.Contains(...)).
مرتب‌سازی: نتایج بر اساس گزینه انتخابی کاربر (ApplyProductSorting) مرتب می‌شوند (مثلاً OrderByDescending(p => p.MaxPrice)).
صفحه‌بندی (Pagination): برای جلوگیری از ارسال حجم زیاد داده، فقط تعداد مشخصی از رکوردها (مثلاً ۱۰ عدد) با استفاده از Skip() و Take() واکشی می‌شود.
نتایج به PublicProductViewDto مپ می‌شوند. این DTO شامل تمام اطلاعات لازم برای نمایش عمومی است، مانند لیست انواع محصول (Variants), تصاویر، محدوده قیمت و موجودی کل.
بهینه‌سازی: نتایج این APIها به دلیل ماهیت عمومی و تکراری بودن، قابلیت کش شدن در Redis (با استفاده از OutputCacheAttribute) را دارند تا درخواست‌های بعدی با سرعت بسیار بالاتری پاسخ داده شوند.
۲. افزودن محصول به سبد خرید (Add to Cart)
این فرآیند باید هم برای کاربر مهمان و هم برای کاربر عضو به درستی کار کند و موجودی انبار را در نظر بگیرد.

نقطه ورود: POST /api/carts/items در CartsController.

جریان فنی:

کاربر یک درخواست POST با بدنه حاوی VariantId و Quantity (که در AddToCartDto تعریف شده) ارسال می‌کند.
CartsController با استفاده از ICurrentUserService، هویت کاربر را بررسی می‌کند:
اگر کاربر لاگین کرده باشد، UserId او در دسترس است.
اگر کاربر مهمان باشد، یک توکن شناسایی (GuestToken) از هدر X-Guest-Token خوانده می‌شود.
کنترلر متد AddItemToCartAsync از ICartService را با شناسه‌های کاربر/مهمان فراخوانی می‌کند.
CartService کارهای زیر را به ترتیب انجام می‌دهد:
ابتدا سبد خرید (Cart) مربوط به کاربر یا مهمان را از دیتابیس یا کش Redis واکشی می‌کند. اگر وجود نداشت، یک سبد جدید می‌سازد.
بررسی موجودی: ProductVariant درخواستی را از دیتابیس واکشی کرده و بررسی می‌کند که آیا موجودی (Stock) کافی برای درخواست کاربر وجود دارد یا خیر (مگر اینکه محصول IsUnlimited باشد).
تداخل‌سنجی (Concurrency Control): اگر RowVersion در AddToCartDto ارسال شده باشد، EF Core آن را با مقدار موجود در دیتابیس مقایسه می‌کند. اگر مغایرت داشته باشد (یعنی شخص دیگری همزمان موجودی را تغییر داده)، یک DbUpdateConcurrencyException پرتاب می‌شود و به کاربر پیام مناسب نمایش داده می‌شود.
اگر آیتم از قبل در سبد موجود باشد، تعداد آن را افزایش می‌دهد؛ در غیر این صورت، یک CartItem جدید به سبد اضافه می‌کند.
تمام تغییرات از طریق IUnitOfWork.SaveChangesAsync() به صورت یک تراکنش واحد در دیتابیس ذخیره می‌شود.
کش سبد خرید کاربر (cart:user:{userId} یا cart:guest:{guestId}) در Redis باطل (Invalidate) می‌شود تا درخواست بعدی، اطلاعات به‌روز را واکشی کند.
سبد خرید به‌روز شده (در قالب CartDto) به کاربر بازگردانده می‌شود.
۳. تکمیل سفارش و پرداخت (Checkout)
این مرحله حساس‌ترین بخش سفر مشتری است و باید کاملاً امن، قابل اطمینان و اتمیک (Atomic) باشد.

نقطه ورود: POST /api/orders/checkout-from-cart در OrdersController.

جریان فنی:

کاربر پس از نهایی کردن سبد خرید، با ارسال UserAddressId و ShippingMethodId در CreateOrderFromCartDto، درخواست تکمیل سفارش را ارسال می‌کند. یک هدر Idempotency-Key نیز برای جلوگیری از درخواست‌های تکراری الزامی است.
OrdersController متد CheckoutFromCartAsync از IOrderService را فراخوانی می‌کند.
OrderService یک فرآیند تراکنشی پیچیده را آغاز می‌کند:
کنترل نرخ درخواست (Rate Limiting): با استفاده از IRateLimitService، تعداد تلاش‌های کاربر برای پرداخت در یک بازه زمانی محدود می‌شود تا از حملات جلوگیری شود.
بررسی Idempotency: ابتدا چک می‌کند آیا سفارشی با این IdempotencyKey قبلاً ثبت شده است یا خیر. اگر بله، از ادامه کار جلوگیری می‌کند.
واکشی و قفل‌گذاری: سبد خرید کاربر (Cart) و موجودی محصولات (ProductVariant) را از دیتابیس واکشی می‌کند.
ایجاد سفارش: یک موجودیت Order جدید با وضعیت "در انتظار پرداخت" ایجاد می‌کند. یک کپی از آدرس کاربر (AddressSnapshot) به صورت JSON در خود سفارش ذخیره می‌شود تا اگر کاربر بعداً آدرسش را تغییر داد، آدرس زمان ثبت سفارش حفظ شود.
ایجاد آیتم‌های سفارش: به ازای هر CartItem، یک OrderItem ایجاد کرده و محاسبات قیمت و سود را انجام می‌دهد.
کاهش موجودی: IInventoryService فراخوانی می‌شود تا به ازای هر OrderItem، موجودی ProductVariant متناظر را کاهش دهد و یک InventoryTransaction با نوع "Sale" ثبت کند.
اعمال کد تخفیف: اگر DiscountCode ارسال شده باشد، IDiscountService آن را اعتبارسنجی کرده و مبلغ تخفیf را محاسبه می‌کند.
محاسبه مبلغ نهایی: هزینه ارسال (ShippingCost) و تخفیف (DiscountAmount) به مبلغ کل اضافه و کم شده و FinalAmount محاسبه می‌شود.
حذف سبد خرید: آیتم‌های سبد خرید کاربر حذف می‌شوند.
ثبت تراکنش: تمام تغییرات فوق (ایجاد سفارش، کاهش موجودی، حذف سبد خرید) با یک بار فراخوانی _unitOfWork.SaveChangesAsync() به صورت اتمیک در دیتابیس ثبت می‌شود. اگر هر یک از این مراحل با خطا مواجه شود، کل عملیات لغو (Rollback) می‌شود.
اتصال به درگاه پرداخت:
IZarinpalService فراخوانی می‌شود تا یک درخواست پرداخت با مبلغ نهایی ایجاد کند.
یک callbackUrl منحصر به فرد (شامل orderId) تولید می‌شود.
در صورت موفقیت، زرین‌پال یک authority و لینک پرداخت برمی‌گرداند. این لینک به کاربر نمایش داده می‌شود.
تأیید پرداخت (Verification):
پس از پرداخت، کاربر به GET /api/orders/verify-payment هدایت می‌شود.
OrderService با استفاده از authority و status دریافتی، پرداخت را از طریق IZarinpalService تأیید می‌کند.
در صورت موفقیت، Order.IsPaid برابر true شده و OrderStatusId به "در حال پردازش" تغییر می‌کند. یک PaymentTransaction برای ثبت دائمی جزئیات پرداخت ایجاد می‌شود.
یک نوتیفیکیشن (Notification) برای کاربر مبنی بر موفقیت پرداخت ایجاد می‌شود.
در نهایت کاربر به صفحه موفقیت یا شکست پرداخت در فرانت‌اند هدایت می‌شود.
بخش دوم: پنل مدیریت (Admin Panel)
پنل مدیریت قلب تپنده عملیات فروشگاه است و به مدیران امکان کنترل کامل بر تمام جنبه‌های سیستم را می‌دهد. دسترسی به تمام این بخش‌ها از طریق [Authorize(Roles = "Admin")] محدود شده است.

۱. مدیریت کاربران (UsersController)
مشاهده لیست کاربران: امکان مشاهده تمام کاربران، حتی کاربران حذف شده (includeDeleted=true).
ایجاد، ویرایش و حذف کاربر: مدیر می‌تواند به صورت دستی کاربر ایجاد کند، اطلاعات کاربری را تغییر دهد یا حساب کاربری را به طور موقت (IsDeleted=true) حذف کند.
تغییر وضعیت کاربر: فعال یا غیرفعال کردن یک کاربر (ChangeUserStatus).
بازیابی کاربر: بازگرداندن یک حساب کاربری حذف شده (RestoreUser).
۲. مدیریت محصولات (ProductsController)
این بخش گسترده‌ترین قابلیت‌ها را دارد:

CRUD کامل محصولات: ایجاد (CreateProduct)، خواندن (GetProduct با جزئیات کامل مدیریتی)، به‌روزرسانی (UpdateProduct) و حذف (DeleteProduct).
مدیریت موجودی: افزایش (AddStock) یا کاهش (RemoveStock) دستی موجودی یک ProductVariant خاص. تمام این تغییرات در InventoryTransaction ثبت می‌شود.
مدیریت قیمت و تخفیf:
تخفیف تکی: امکان تنظیم تخفیف برای یک ProductVariant خاص با تعیین قیمت اصلی و قیمت فروش (SetProductDiscount).
به‌روزرسانی گروهی قیمت‌ها: قابلیت تغییر قیمت خرید یا فروش چندین محصول به صورت همزمان (BulkUpdatePrices) که برای مدیریت سریع قیمت‌ها بسیار کارآمد است.
گزارش‌گیری:
آمار محصولات: دریافت آمار کلی مانند تعداد کل محصولات، محصولات فعال، محصولات ناموجود و ارزش کل انبار (GetProductStatistics).
محصولات رو به اتمام: دریافت لیستی از محصولاتی که موجودی آن‌ها از یک حد مشخص (threshold) کمتر است (GetLowStockProducts).
۳. مدیریت دسته‌بندی‌ها (CategoryController & CategoryGroupController)
CRUD کامل دسته‌بندی‌ها و زیرمجموعه‌ها: مدیران می‌توانند ساختار درختی محصولات را به طور کامل مدیریت کنند، از جمله افزودن، ویرایش و حذف Category و CategoryGroup.
مدیریت تصاویر: امکان آپلود و مدیریت آیکون برای هر دسته‌بندی.
حذف هوشمند: سیستم اجازه حذف دسته‌بندی‌ای که محصول فعال دارد را نمی‌دهد تا از ایجاد داده‌های ناقص (Orphan Data) جلوگیری شود.
۴. مدیریت سفارشات (OrdersController & OrderItemsController)
مشاهده و فیلتر سفارشات: مشاهده تمام سفارشات با قابلیت فیلتر بر اساس کاربر، وضعیت سفارش و بازه زمانی. مدیر به جزئیات کامل سفارش، از جمله سود هر آیتم، دسترسی دارد.
تغییر وضعیت سفارش: امکان تغییر دستی وضعیت یک سفارش (مثلاً از "در حال پردازش" به "ارسال شده") از طریق PATCH /api/orders/{id}/status.
ویرایش جزئیات سفارش: مدیر می‌تواند آیتم‌های یک سفارش را ویرایش (UpdateOrderItem) یا حذف (DeleteOrderItem) کند. این عملیات به طور خودکار موجودی انبار را اصلاح کرده و در InventoryTransaction ثبت می‌شود.
آمار فروش: دریافت گزارش‌های آماری از فروش در بازه‌های زمانی مختلف (GetOrderStatistics).
۵. مدیریت نظرات (ReviewsController)
سیستم تأیید نظرات: نظرات ثبت شده توسط کاربران به صورت پیش‌فرض در وضعیت "Pending" قرار می‌گیرند.
مدیریت وضعیت: مدیر می‌تواند نظرات را مشاهده کرده و وضعیت آن‌ها را به "Approved" (تأیید شده) یا "Rejected" (رد شده) تغییر دهد (UpdateReviewStatus).
حذف نظرات: امکان حذف کامل یک نظر.
۶. لاگ‌ها و بازرسی (AuditController)
ردیابی کامل: این بخش به مدیران امکان می‌دهد تمام رویدادهای ثبت شده در سیستم را مشاهده کنند (GetAuditLogs).
فیلترینگ پیشرفته: می‌توان لاگ‌ها را بر اساس کاربر، نوع رویداد (مانند LoginSuccess, OrderEvent) و بازه زمانی فیلتر کرد که برای عیب‌یابی و بررسی‌های امنیتی حیاتی است.