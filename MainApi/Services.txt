namespace MainApi.Controllers.Cart;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class CartItemsController : ControllerBase
{
    private readonly MechanicContext _context;

    public CartItemsController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet("cart-items")]
    public async Task<ActionResult<IEnumerable<CartItemDto>>> GetCartItems()
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        var cartItems = await _context.TCartItems
            .Include(ci => ci.Product)
            .Include(ci => ci.Cart)
            .Where(ci => ci.Cart.UserId == userId)
            .Select(ci => new CartItemDto
            {
                Id = ci.Id,
                ProductId = ci.ProductId,
                ProductName = ci.Product.Name ?? "",
                SellingPrice = ci.Product.SellingPrice ?? 0,
                Quantity = ci.Quantity,
                TotalPrice = (ci.Product.SellingPrice ?? 0) * ci.Quantity
            })
            .ToListAsync();

        return Ok(cartItems);
    }

    [HttpGet("cart-items/{id}")]
    public async Task<ActionResult<CartItemDto>> GetCartItem(int id)
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        var cartItem = await _context.TCartItems
            .Include(ci => ci.Product)
            .Include(ci => ci.Cart)
            .Where(ci => ci.Id == id && ci.Cart.UserId == userId)
            .Select(ci => new CartItemDto
            {
                Id = ci.Id,
                ProductId = ci.ProductId,
                ProductName = ci.Product.Name ?? "",
                SellingPrice = ci.Product.SellingPrice ?? 0,
                Quantity = ci.Quantity,
                TotalPrice = (ci.Product.SellingPrice ?? 0) * ci.Quantity
            })
            .FirstOrDefaultAsync();

        if (cartItem == null)
            return NotFound("Cart item not found");

        return Ok(cartItem);
    }

    private int GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst("id")?.Value;
        if (string.IsNullOrEmpty(userIdClaim) || !int.TryParse(userIdClaim, out int userId))
            return 0;
        return userId;
    }
}


namespace MainApi.Controllers.Cart;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class CartsController : ControllerBase
{
    private readonly MechanicContext _context;
    public CartsController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet("my-cart")]
    public async Task<ActionResult<CartDto>> GetMyCart()
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");
        var cart = await _context.TCarts
            .Include(c => c.CartItems)
            .ThenInclude(ci => ci.Product)
            .FirstOrDefaultAsync(c => c.UserId == userId);
        if (cart == null)
        {
            cart = new TCarts { UserId = userId, TotalItems = 0, TotalPrice = 0 };
            _context.TCarts.Add(cart);
            await _context.SaveChangesAsync();
        }

        var cartDto = new CartDto
        {
            Id = cart.Id,
            UserId = cart.UserId,
            CartItems = cart.CartItems?.Select(ci => new CartItemDto
            {
                Id = ci.Id,
                ProductId = ci.ProductId,
                ProductName = ci.Product?.Name ?? "",
                SellingPrice = ci.Product?.SellingPrice ?? 0,
                Quantity = ci.Quantity,
                TotalPrice = (ci.Product?.SellingPrice ?? 0) * ci.Quantity
            }).ToList() ?? new List<CartItemDto>(),
            TotalItems = cart.TotalItems,
            TotalPrice = cart.TotalPrice
        };

        return Ok(cartDto);
    }

    [HttpPost("add-item")]
    public async Task<ActionResult> AddToCart([FromBody] AddToCartDto dto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        var cart = await _context.TCarts
            .Include(c => c.CartItems)
            .FirstOrDefaultAsync(c => c.UserId == userId);

        if (cart == null)
        {
            cart = new TCarts { UserId = userId };
            _context.TCarts.Add(cart);
            await _context.SaveChangesAsync();
        }

        try
        {
            var product = await _context.TProducts.FindAsync(dto.ProductId);
            if (product == null)
                return NotFound("Product not found");
            if ((product.Count ?? 0) < dto.Quantity)
                return BadRequest("Insufficient stock");

            var existingItem = cart.CartItems?.FirstOrDefault(ci => ci.ProductId == dto.ProductId);
            if (existingItem != null)
            {
                var newQuantity = existingItem.Quantity + dto.Quantity;
                if (newQuantity > (product.Count ?? 0))
                {
                    return BadRequest("Total quantity exceeds available stock");
                }
                existingItem.Quantity = newQuantity;
            }
            else
            {
                var cartItem = new TCartItems
                {
                    CartId = cart.Id,
                    ProductId = dto.ProductId,
                    Quantity = dto.Quantity
                };
                _context.TCartItems.Add(cartItem);
            }

            cart.TotalItems += dto.Quantity;
            cart.TotalPrice += (product.SellingPrice ?? 0) * dto.Quantity;

            await _context.SaveChangesAsync();
            return Ok(new { Message = "Item added to cart successfully" });
        }
        catch (DbUpdateConcurrencyException)
        {
            return Conflict("The stock for this item has just changed. Please try again.");
        }
    }

    [HttpPut("update-item/{itemId}")]
    public async Task<ActionResult> UpdateCartItem(int itemId, [FromBody] UpdateCartItemDto dto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");
        var cartItem = await _context.TCartItems
            .Include(ci => ci.Cart)
            .Include(ci => ci.Product)
            .FirstOrDefaultAsync(ci => ci.Id == itemId && ci.Cart.UserId == userId);
        if (cartItem == null)
            return NotFound("Cart item not found");
        if (dto.Quantity > (cartItem.Product?.Count ?? 0))
            return BadRequest("Quantity exceeds available stock");

        int quantityDifference = dto.Quantity - cartItem.Quantity;
        cartItem.Cart.TotalItems += quantityDifference;
        cartItem.Cart.TotalPrice += (cartItem.Product?.SellingPrice ?? 0) * quantityDifference;
        cartItem.Quantity = dto.Quantity;

        await _context.SaveChangesAsync();
        return Ok(new { Message = "Cart item updated successfully" });
    }

    [HttpDelete("remove-item/{itemId}")]
    public async Task<ActionResult> RemoveFromCart(int itemId)
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");
        var cartItem = await _context.TCartItems
            .Include(ci => ci.Cart)
            .Include(ci => ci.Product)
            .FirstOrDefaultAsync(ci => ci.Id == itemId && ci.Cart.UserId == userId);
        if (cartItem == null)
            return NotFound("Cart item not found");

        cartItem.Cart.TotalItems -= cartItem.Quantity;
        cartItem.Cart.TotalPrice -= (cartItem.Product?.SellingPrice ?? 0) * cartItem.Quantity;

        _context.TCartItems.Remove(cartItem);
        await _context.SaveChangesAsync();

        return Ok(new { Message = "Item removed from cart successfully" });
    }

    [HttpDelete("clear")]
    public async Task<ActionResult> ClearCart()
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");
        var cart = await _context.TCarts
            .Include(c => c.CartItems)
            .FirstOrDefaultAsync(c => c.UserId == userId);
        if (cart == null || !cart.CartItems.Any())
            return Ok(new { Message = "Cart is already empty" });

        _context.TCartItems.RemoveRange(cart.CartItems);
        cart.TotalItems = 0;
        cart.TotalPrice = 0;
        await _context.SaveChangesAsync();

        return Ok(new { Message = "Cart cleared successfully" });
    }

    [HttpGet("count")]
    public async Task<ActionResult<int>> GetCartItemsCount()
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");
        var count = await _context.TCarts
            .Where(c => c.UserId == userId)
            .Select(c => c.TotalItems)
            .FirstOrDefaultAsync();
        return Ok(count);
    }

    private int GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst("id")?.Value;
        if (string.IsNullOrEmpty(userIdClaim) || !int.TryParse(userIdClaim, out int userId))
            return 0;
        return userId;
    }
}


namespace MainApi.Controllers.Order;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class OrderStatusController : ControllerBase
{
    private readonly MechanicContext _context;

    public OrderStatusController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<object>>> GetTOrderStatus()
    {
        var orderStatuses = await _context.TOrderStatus
            .Select(s => new
            {
                s.Id,
                s.Name,
                s.Icon,
                OrderCount = s.Orders != null ? s.Orders.Count() : 0
            })
            .ToListAsync();

        return Ok(orderStatuses);
    }

    [HttpGet("no-order/{id}")]
    public async Task<ActionResult<object>> GetTOrderStatus(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order status ID");

        var orderStatus = await _context.TOrderStatus
            .Select(s => new
            {
                s.Id,
                s.Name,
                s.Icon,
                OrderCount = s.Orders != null ? s.Orders.Count() : 0,
            })
            .FirstOrDefaultAsync(s => s.Id == id);

        if (orderStatus == null)
            return NotFound();

        return Ok(orderStatus);
    }

    [HttpPost]
    public async Task<ActionResult<TOrderStatus>> PostTOrderStatus(CreateOrderStatusDto statusDto)
    {
        if (statusDto == null)
            return BadRequest("Order status data is required");

        if (string.IsNullOrWhiteSpace(statusDto.Name))
            return BadRequest("Name is required");

        var orderStatus = new TOrderStatus
        {
            Name = statusDto.Name,
            Icon = statusDto.Icon
        };

        _context.TOrderStatus.Add(orderStatus);
        await _context.SaveChangesAsync();

        return CreatedAtAction("GetTOrderStatus", new { id = orderStatus.Id }, orderStatus);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> PutTOrderStatus(int id, UpdateOrderStatusDto statusDto)
    {
        if (id <= 0)
            return BadRequest("Invalid order status ID");

        if (statusDto == null)
            return BadRequest("Order status data is required");

        var orderStatus = await _context.TOrderStatus.FindAsync(id);
        if (orderStatus == null)
            return NotFound();

        if (statusDto.Name != null)
        {
            if (string.IsNullOrWhiteSpace(statusDto.Name))
                return BadRequest("Name cannot be empty");
            orderStatus.Name = statusDto.Name;
        }

        if (statusDto.Icon != null)
            orderStatus.Icon = statusDto.Icon;

        try
        {
            await _context.SaveChangesAsync();
            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!TOrderStatusExists(id))
                return NotFound();
            throw;
        }
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteTOrderStatus(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order status ID");

        var orderStatus = await _context.TOrderStatus.FindAsync(id);
        if (orderStatus == null)
            return NotFound();

        var hasOrders = await _context.TOrders.AnyAsync(o => o.OrderStatusId == id);
        if (hasOrders)
            return BadRequest("Cannot delete order status that is being used by orders");

        _context.TOrderStatus.Remove(orderStatus);
        await _context.SaveChangesAsync();

        return NoContent();
    }

    private bool TOrderStatusExists(int id)
    {
        return _context.TOrderStatus.Any(e => e.Id == id);
    }
}


namespace MainApi.Controllers.Order;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class OrdersController : ControllerBase
{
    private readonly MechanicContext _context;

    public OrdersController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<object>>> GetTOrders(
        [FromQuery] int? userId = null,
        [FromQuery] int? statusId = null,
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null,
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 10)
    {
        if (page < 1) page = 1;
        if (pageSize < 1 || pageSize > 100) pageSize = 10;

        var query = _context.TOrders
            .Include(o => o.User)
            .Include(o => o.OrderStatus)
            .Include(o => o.OrderItems)
                .ThenInclude(oi => oi.Product)
            .AsQueryable();

        if (userId.HasValue)
            query = query.Where(o => o.UserId == userId.Value);

        if (statusId.HasValue)
            query = query.Where(o => o.OrderStatusId == statusId.Value);

        if (fromDate.HasValue)
            query = query.Where(o => o.CreatedAt >= fromDate.Value);

        if (toDate.HasValue)
            query = query.Where(o => o.CreatedAt <= toDate.Value);

        var totalCount = await query.CountAsync();
        var orders = await query
            .OrderByDescending(o => o.CreatedAt)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .Select(o => new
            {
                o.Id,
                o.Name,
                o.Address,
                o.PostalCode,
                o.TotalAmount,
                o.TotalProfit,
                o.CreatedAt,
                o.DeliveryDate,
                User = new
                {
                    o.User.Id,
                    o.User.PhoneNumber,
                    o.User.FirstName,
                    o.User.LastName
                },
                OrderStatus = new
                {
                    o.OrderStatus.Id,
                    o.OrderStatus.Name,
                    o.OrderStatus.Icon
                },
                OrderItemsCount = o.OrderItems.Count()
            })
            .ToListAsync();

        return Ok(new
        {
            Data = orders,
            TotalCount = totalCount,
            Page = page,
            PageSize = pageSize,
            TotalPages = (int)Math.Ceiling(totalCount / (double)pageSize)
        });
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<object>> GetOrderById(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order ID");

        var order = await _context.TOrders
            .Include(o => o.User)
            .Include(o => o.OrderStatus)
            .Include(o => o.OrderItems)
                .ThenInclude(oi => oi.Product)
                    .ThenInclude(p => p.ProductType)
            .Select(o => new
            {
                o.Id,
                o.Name,
                o.Address,
                o.PostalCode,
                o.TotalAmount,
                o.TotalProfit,
                o.CreatedAt,
                o.DeliveryDate,
                User = new
                {
                    o.User.Id,
                    o.User.PhoneNumber,
                    o.User.FirstName,
                    o.User.LastName
                },
                OrderStatus = new
                {
                    o.OrderStatus.Id,
                    o.OrderStatus.Name,
                    o.OrderStatus.Icon
                },
                OrderItems = o.OrderItems.Select(oi => new
                {
                    oi.Id,
                    oi.PurchasePrice,
                    oi.SellingPrice,
                    oi.Quantity,
                    oi.Amount,
                    oi.Profit,
                    Product = new
                    {
                        oi.Product.Id,
                        oi.Product.Name,
                        oi.Product.Icon,
                        ProductType = new
                        {
                            oi.Product.ProductType.Id,
                            oi.Product.ProductType.Name
                        }
                    }
                })
            })
            .FirstOrDefaultAsync(o => o.Id == id);

        if (order == null)
            return NotFound();

        return Ok(order);
    }

    [HttpPost]
    public async Task<ActionResult<TOrders>> PostTOrders(CreateOrderDto orderDto)
    {
        if (orderDto == null)
            return BadRequest("Order data is required");

        if (string.IsNullOrWhiteSpace(orderDto.Address) || string.IsNullOrWhiteSpace(orderDto.PostalCode))
            return BadRequest("Address and PostalCode are required");

        if (orderDto.OrderItems == null || !orderDto.OrderItems.Any())
            return BadRequest("At least one order item is required");

        if (!await _context.TUsers.AnyAsync(u => u.Id == orderDto.UserId))
            return BadRequest("Invalid user ID");

        if (!await _context.TOrderStatus.AnyAsync(s => s.Id == orderDto.OrderStatusId))
            return BadRequest("Invalid order status ID");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var order = new TOrders
            {
                UserId = orderDto.UserId,
                Name = orderDto.Name,
                Address = orderDto.Address,
                PostalCode = orderDto.PostalCode,
                CreatedAt = DateTime.UtcNow,
                OrderStatusId = orderDto.OrderStatusId,
                DeliveryDate = orderDto.DeliveryDate
            };

            _context.TOrders.Add(order);
            await _context.SaveChangesAsync();

            var totalAmount = 0;
            var totalProfit = 0;

            foreach (var itemDto in orderDto.OrderItems)
            {
                if (itemDto.Quantity <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Invalid quantity for product {itemDto.ProductId}");
                }

                if (itemDto.SellingPrice <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Invalid selling price for product {itemDto.ProductId}");
                }

                var product = await _context.TProducts.FindAsync(itemDto.ProductId);
                if (product == null)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {itemDto.ProductId} not found");
                }

                if ((product.Count ?? 0) < itemDto.Quantity)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {itemDto.ProductId} insufficient stock. Available: {product.Count ?? 0}, Requested: {itemDto.Quantity}");
                }

                var orderItem = new TOrderItems
                {
                    UserOrderId = order.Id,
                    ProductId = itemDto.ProductId,
                    PurchasePrice = product.PurchasePrice ?? 0,
                    SellingPrice = itemDto.SellingPrice,
                    Quantity = itemDto.Quantity,
                    Amount = itemDto.SellingPrice * itemDto.Quantity,
                    Profit = (itemDto.SellingPrice - (product.PurchasePrice ?? 0)) * itemDto.Quantity
                };

                totalAmount += orderItem.Amount;
                totalProfit += orderItem.Profit;

                product.Count -= itemDto.Quantity;
                _context.TOrderItems.Add(orderItem);
            }

            order.TotalAmount = totalAmount;
            order.TotalProfit = totalProfit;

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return CreatedAtAction(nameof(GetOrderById), new { id = order.Id }, order);
        }
        catch (Exception)
        {
            await transaction.RollbackAsync();
            throw;
        }
    }

    [HttpPost("checkout-from-cart")]
    public async Task<ActionResult<TOrders>> CheckoutFromCart([FromBody] CreateOrderDto orderDto)
    {
        if (orderDto == null || string.IsNullOrWhiteSpace(orderDto.Address) || string.IsNullOrWhiteSpace(orderDto.PostalCode))
            return BadRequest("Address and PostalCode are required");

        var userId = GetCurrentUserId();
        if (userId == null)
            return Unauthorized();

        var idempotencyKey = Request.Headers["Idempotency-Key"].FirstOrDefault();
        if (!string.IsNullOrEmpty(idempotencyKey))
        {
            var existingOrder = await _context.TOrders
                .FirstOrDefaultAsync(o => o.Name == idempotencyKey && o.UserId == userId.Value);
            if (existingOrder != null)
                return Conflict(new { Message = "Duplicate request", OrderId = existingOrder.Id });
        }

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var cart = await _context.TCarts
                .Include(c => c.CartItems)
                .ThenInclude(ci => ci.Product)
                .FirstOrDefaultAsync(c => c.UserId == userId.Value);

            if (cart == null || cart.CartItems == null || !cart.CartItems.Any())
                return BadRequest("Cart is empty");

            var order = new TOrders
            {
                UserId = userId.Value,
                Name = idempotencyKey ?? $"Order-{Guid.NewGuid()}",
                Address = orderDto.Address,
                PostalCode = orderDto.PostalCode,
                CreatedAt = DateTime.UtcNow,
                OrderStatusId = 1
            };

            _context.TOrders.Add(order);
            await _context.SaveChangesAsync();

            var totalAmount = 0;
            var totalProfit = 0;

            foreach (var item in cart.CartItems)
            {
                if (item.Quantity <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Invalid quantity for product {item.ProductId}");
                }

                var product = await _context.TProducts.FirstOrDefaultAsync(p => p.Id == item.ProductId);
                if (product == null)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {item.ProductId} not found");
                }

                if ((product.Count ?? 0) < item.Quantity)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {item.ProductId} insufficient stock. Available: {product.Count ?? 0}, Requested: {item.Quantity}");
                }

                if ((product.SellingPrice ?? 0) <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {item.ProductId} has invalid price");
                }

                var orderItem = new TOrderItems
                {
                    UserOrderId = order.Id,
                    ProductId = product.Id,
                    PurchasePrice = product.PurchasePrice ?? 0,
                    SellingPrice = product.SellingPrice ?? 0,
                    Quantity = item.Quantity,
                    Amount = (product.SellingPrice ?? 0) * item.Quantity,
                    Profit = ((product.SellingPrice ?? 0) - (product.PurchasePrice ?? 0)) * item.Quantity
                };

                totalAmount += orderItem.Amount;
                totalProfit += orderItem.Profit;

                product.Count -= item.Quantity;
                _context.TOrderItems.Add(orderItem);
            }

            order.TotalAmount = totalAmount;
            order.TotalProfit = totalProfit;

            _context.TCartItems.RemoveRange(cart.CartItems);

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return CreatedAtAction(nameof(GetOrderById), new { id = order.Id }, order);
        }
        catch (Exception)
        {
            await transaction.RollbackAsync();
            throw;
        }
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> PutTOrders(int id, UpdateOrderDto orderDto)
    {
        if (id <= 0)
            return BadRequest("Invalid order ID");

        if (orderDto == null)
            return BadRequest("Order data is required");

        var order = await _context.TOrders.FindAsync(id);
        if (order == null)
            return NotFound();

        if (orderDto.OrderStatusId.HasValue && !await _context.TOrderStatus.AnyAsync(s => s.Id == orderDto.OrderStatusId.Value))
            return BadRequest("Invalid order status ID");

        order.Name = orderDto.Name ?? order.Name;
        order.Address = orderDto.Address ?? order.Address;
        order.PostalCode = orderDto.PostalCode ?? order.PostalCode;
        order.DeliveryDate = orderDto.DeliveryDate ?? order.DeliveryDate;

        if (orderDto.OrderStatusId.HasValue)
            order.OrderStatusId = orderDto.OrderStatusId.Value;

        try
        {
            await _context.SaveChangesAsync();
            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!TOrdersExists(id))
                return NotFound();
            throw;
        }
    }

    [HttpPut("{id}/status")]
    public async Task<IActionResult> UpdateOrderStatus(int id, [FromBody] UpdateOrderStatusDto statusDto)
    {
        if (id <= 0)
            return BadRequest("Invalid order ID");

        if (statusDto == null)
            return BadRequest("Status data is required");

        var order = await _context.TOrders.FindAsync(id);
        if (order == null)
            return NotFound();

        if (!await _context.TOrderStatus.AnyAsync(s => s.Id == statusDto.OrderStatusId))
            return BadRequest("Invalid order status ID");

        order.OrderStatusId = statusDto.OrderStatusId;

        try
        {
            await _context.SaveChangesAsync();
            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!TOrdersExists(id))
                return NotFound();
            throw;
        }
    }

    [HttpGet("statistics")]
    public async Task<ActionResult<object>> GetOrderStatistics(
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null)
    {
        var query = _context.TOrders.AsQueryable();

        if (fromDate.HasValue)
            query = query.Where(o => o.CreatedAt >= fromDate.Value);

        if (toDate.HasValue)
            query = query.Where(o => o.CreatedAt <= toDate.Value);

        var statistics = await query
            .GroupBy(o => 1)
            .Select(g => new
            {
                TotalOrders = g.Count(),
                TotalRevenue = g.Sum(o => o.TotalAmount),
                TotalProfit = g.Sum(o => o.TotalProfit),
                AverageOrderValue = g.Average(o => (double)o.TotalAmount)
            })
            .FirstOrDefaultAsync();

        var statusStatistics = await _context.TOrders
            .Include(o => o.OrderStatus)
            .Where(o => fromDate == null || o.CreatedAt >= fromDate.Value)
            .Where(o => toDate == null || o.CreatedAt <= toDate.Value)
            .GroupBy(o => new { o.OrderStatusId, o.OrderStatus.Name })
            .Select(g => new
            {
                StatusId = g.Key.OrderStatusId,
                StatusName = g.Key.Name,
                Count = g.Count()
            })
            .ToListAsync();

        return Ok(new
        {
            GeneralStatistics = statistics ?? new
            {
                TotalOrders = 0,
                TotalRevenue = 0,
                TotalProfit = 0,
                AverageOrderValue = 0.0
            },
            StatusStatistics = statusStatistics
        });
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteTOrders(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order ID");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var order = await _context.TOrders
                .Include(o => o.OrderItems)
                    .ThenInclude(oi => oi.Product)
                .FirstOrDefaultAsync(o => o.Id == id);

            if (order == null)
                return NotFound();

            foreach (var orderItem in order.OrderItems)
            {
                if (orderItem.Product != null)
                {
                    orderItem.Product.Count += orderItem.Quantity;
                }
            }

            _context.TOrderItems.RemoveRange(order.OrderItems);
            _context.TOrders.Remove(order);

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return NoContent();
        }
        catch (Exception)
        {
            await transaction.RollbackAsync();
            throw;
        }
    }

    private bool TOrdersExists(int id)
    {
        return _context.TOrders.Any(e => e.Id == id);
    }

    private int? GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        return int.TryParse(userIdClaim, out var userId) ? userId : null;
    }
}


namespace MainApi.Controllers.Order;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class OrderItemsController : ControllerBase
{
    private readonly MechanicContext _context;

    public OrderItemsController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<object>>> GetTOrderItems([FromQuery] int? orderId = null)
    {
        var query = _context.TOrderItems
            .Include(oi => oi.Product)
                .ThenInclude(p => p.ProductType)
            .Include(oi => oi.UserOrder)
            .AsQueryable();

        if (orderId.HasValue)
        {
            if (orderId.Value <= 0)
                return BadRequest("Invalid order ID");
            query = query.Where(oi => oi.UserOrderId == orderId.Value);
        }

        var orderItems = await query
            .Select(oi => new
            {
                oi.Id,
                oi.PurchasePrice,
                oi.SellingPrice,
                oi.Quantity,
                oi.Amount,
                oi.Profit,
                Product = new
                {
                    oi.Product.Id,
                    oi.Product.Name,
                    oi.Product.Icon,
                    ProductType = new
                    {
                        oi.Product.ProductType.Id,
                        oi.Product.ProductType.Name
                    }
                },
                Order = new
                {
                    oi.UserOrder.Id,
                    oi.UserOrder.Name,
                    oi.UserOrder.CreatedAt
                }
            })
            .ToListAsync();

        return Ok(orderItems);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<object>> GetTOrderItems(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order item ID");

        var orderItem = await _context.TOrderItems
            .Include(oi => oi.Product)
                .ThenInclude(p => p.ProductType)
            .Include(oi => oi.UserOrder)
                .ThenInclude(o => o.User)
            .Select(oi => new
            {
                oi.Id,
                oi.PurchasePrice,
                oi.SellingPrice,
                oi.Quantity,
                oi.Amount,
                oi.Profit,
                Product = new
                {
                    oi.Product.Id,
                    oi.Product.Name,
                    oi.Product.Icon,
                    oi.Product.PurchasePrice,
                    oi.Product.SellingPrice,
                    oi.Product.Count,
                    ProductType = new
                    {
                        oi.Product.ProductType.Id,
                        oi.Product.ProductType.Name
                    }
                },
                Order = new
                {
                    oi.UserOrder.Id,
                    oi.UserOrder.Name,
                    oi.UserOrder.Address,
                    oi.UserOrder.CreatedAt,
                    User = new
                    {
                        oi.UserOrder.User.Id,
                        oi.UserOrder.User.PhoneNumber,
                        oi.UserOrder.User.FirstName,
                        oi.UserOrder.User.LastName
                    }
                }
            })
            .FirstOrDefaultAsync(oi => oi.Id == id);

        if (orderItem == null)
            return NotFound();

        return Ok(orderItem);
    }

    [HttpPost]
    public async Task<ActionResult<TOrderItems>> PostTOrderItems(CreateOrderItemDto itemDto)
    {
        if (itemDto == null)
            return BadRequest("Order item data is required");

        if (itemDto.Quantity <= 0)
            return BadRequest("Quantity must be greater than 0");

        if (itemDto.SellingPrice <= 0)
            return BadRequest("Selling price must be greater than 0");

        var product = await _context.TProducts.FindAsync(itemDto.ProductId);
        if (product == null)
            return BadRequest("Product not found");

        if ((product.Count ?? 0) < itemDto.Quantity)
            return BadRequest($"Insufficient product stock. Available: {product.Count ?? 0}, Requested: {itemDto.Quantity}");

        var order = await _context.TOrders.FindAsync(itemDto.UserOrderId);
        if (order == null)
            return BadRequest("Order not found");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var orderItem = new TOrderItems
            {
                UserOrderId = itemDto.UserOrderId,
                ProductId = itemDto.ProductId,
                PurchasePrice = product.PurchasePrice ?? 0,
                SellingPrice = itemDto.SellingPrice,
                Quantity = itemDto.Quantity,
                Amount = itemDto.SellingPrice * itemDto.Quantity,
                Profit = (itemDto.SellingPrice - (product.PurchasePrice ?? 0)) * itemDto.Quantity
            };

            _context.TOrderItems.Add(orderItem);
            product.Count -= itemDto.Quantity;

            order.TotalAmount += orderItem.Amount;
            order.TotalProfit += orderItem.Profit;

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return CreatedAtAction("GetTOrderItems", new { id = orderItem.Id }, orderItem);
        }
        catch (Exception)
        {
            await transaction.RollbackAsync();
            throw;
        }
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> PutTOrderItems(int id, UpdateOrderItemDto itemDto)
    {
        if (id <= 0)
            return BadRequest("Invalid order item ID");

        if (itemDto == null)
            return BadRequest("Order item data is required");

        var orderItem = await _context.TOrderItems
            .Include(oi => oi.Product)
            .Include(oi => oi.UserOrder)
            .FirstOrDefaultAsync(oi => oi.Id == id);

        if (orderItem == null)
            return NotFound();

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var oldAmount = orderItem.Amount;
            var oldProfit = orderItem.Profit;
            var oldQuantity = orderItem.Quantity;

            if (itemDto.Quantity.HasValue)
            {
                if (itemDto.Quantity.Value <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest("Quantity must be greater than 0");
                }

                if (itemDto.Quantity.Value != oldQuantity)
                {
                    var quantityDifference = itemDto.Quantity.Value - oldQuantity;

                    if ((orderItem.Product.Count ?? 0) < quantityDifference)
                    {
                        await transaction.RollbackAsync();
                        return BadRequest($"Insufficient product stock. Available: {orderItem.Product.Count ?? 0}, Additional needed: {quantityDifference}");
                    }

                    orderItem.Product.Count -= quantityDifference;
                    orderItem.Quantity = itemDto.Quantity.Value;
                }
            }

            if (itemDto.SellingPrice.HasValue)
            {
                if (itemDto.SellingPrice.Value <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest("Selling price must be greater than 0");
                }
                orderItem.SellingPrice = itemDto.SellingPrice.Value;
            }

            orderItem.Amount = orderItem.SellingPrice * orderItem.Quantity;
            orderItem.Profit = (orderItem.SellingPrice - orderItem.PurchasePrice) * orderItem.Quantity;

            orderItem.UserOrder.TotalAmount = orderItem.UserOrder.TotalAmount - oldAmount + orderItem.Amount;
            orderItem.UserOrder.TotalProfit = orderItem.UserOrder.TotalProfit - oldProfit + orderItem.Profit;

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            await transaction.RollbackAsync();
            if (!TOrderItemsExists(id))
                return NotFound();
            throw;
        }
        catch (Exception)
        {
            await transaction.RollbackAsync();
            throw;
        }
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteTOrderItems(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order item ID");

        var orderItem = await _context.TOrderItems
            .Include(oi => oi.Product)
            .Include(oi => oi.UserOrder)
            .FirstOrDefaultAsync(oi => oi.Id == id);

        if (orderItem == null)
            return NotFound();

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            if (orderItem.Product != null)
                orderItem.Product.Count += orderItem.Quantity;

            orderItem.UserOrder.TotalAmount -= orderItem.Amount;
            orderItem.UserOrder.TotalProfit -= orderItem.Profit;

            _context.TOrderItems.Remove(orderItem);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return NoContent();
        }
        catch (Exception)
        {
            await transaction.RollbackAsync();
            throw;
        }
    }

    private bool TOrderItemsExists(int id)
    {
        return _context.TOrderItems.Any(e => e.Id == id);
    }
}


namespace MainApi.Controllers.Product;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class ProductsController : ControllerBase
{
    private readonly MechanicContext _context;

    public ProductsController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<object>>> GetTProducts([FromQuery] ProductSearchDto search)
    {
        if (search == null)
        {
            search = new ProductSearchDto();
        }

        if (search.Page < 1) search.Page = 1;
        if (search.PageSize < 1) search.PageSize = 10;
        if (search.PageSize > 100) search.PageSize = 100;

        var query = _context.TProducts.Include(p => p.ProductType).AsQueryable();

        if (!string.IsNullOrEmpty(search.Name))
        {
            query = query.Where(p => p.Name.Contains(search.Name));
        }

        if (search.ProductTypeId.HasValue)
        {
            query = query.Where(p => p.ProductTypeId == search.ProductTypeId);
        }

        if (search.MinPrice.HasValue)
        {
            query = query.Where(p => p.SellingPrice >= search.MinPrice);
        }

        if (search.MaxPrice.HasValue)
        {
            query = query.Where(p => p.SellingPrice <= search.MaxPrice);
        }

        if (search.InStock.HasValue)
        {
            if (search.InStock.Value)
                query = query.Where(p => p.Count > 0);
            else
                query = query.Where(p => p.Count == 0 || p.Count == null);
        }

        var totalItems = await query.CountAsync();
        var items = await query
            .Skip((search.Page - 1) * search.PageSize)
            .Take(search.PageSize)
            .Select(p => new
            {
                p.Id,
                p.Name,
                p.Icon,
                p.PurchasePrice,
                p.SellingPrice,
                p.Count,
                p.ProductTypeId,
                ProductType = p.ProductType != null ? new { p.ProductType.Id, p.ProductType.Name } : null,
            })
            .ToListAsync();

        var totalPages = totalItems == 0 ? 1 : (int)Math.Ceiling((double)totalItems / search.PageSize);

        return Ok(new
        {
            Items = items,
            TotalItems = totalItems,
            Page = search.Page,
            PageSize = search.PageSize,
            TotalPages = totalPages
        });
    }

    [HttpGet("low-stock")]
    public async Task<ActionResult<IEnumerable<object>>> GetLowStockProducts([FromQuery] int threshold = 5)
    {
        if (threshold < 0) threshold = 5;

        var products = await _context.TProducts
            .Include(p => p.ProductType)
            .Where(p => p.Count.HasValue && p.Count <= threshold)
            .Select(p => new
            {
                p.Id,
                p.Name,
                p.Count,
                ProductType = p.ProductType != null ? p.ProductType.Name : null,
                p.SellingPrice
            })
            .OrderBy(p => p.Count)
            .ToListAsync();

        return Ok(products);
    }

    [HttpGet("statistics")]
    public async Task<ActionResult<object>> GetProductStatistics()
    {
        var totalProducts = await _context.TProducts.CountAsync();
        var totalValue = await _context.TProducts
            .Where(p => p.Count.HasValue && p.PurchasePrice.HasValue)
            .SumAsync(p => (long?)p.Count * p.PurchasePrice);
        var outOfStockCount = await _context.TProducts
            .CountAsync(p => !p.Count.HasValue || p.Count == 0);
        var lowStockCount = await _context.TProducts
            .CountAsync(p => p.Count.HasValue && p.Count <= 5 && p.Count > 0);

        return Ok(new
        {
            TotalProducts = totalProducts,
            TotalInventoryValue = totalValue ?? 0,
            OutOfStockProducts = outOfStockCount,
            LowStockProducts = lowStockCount
        });
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<object>> GetTProducts(int id)
    {
        if (id <= 0)
        {
            return BadRequest("Invalid product ID");
        }

        var product = await _context.TProducts
            .Include(p => p.ProductType)
            .Where(p => p.Id == id)
            .Select(p => new
            {
                p.Id,
                p.Name,
                p.Icon,
                p.PurchasePrice,
                p.SellingPrice,
                p.Count,
                p.ProductTypeId,
                ProductType = p.ProductType != null ? new { p.ProductType.Id, p.ProductType.Name } : null,
            })
            .FirstOrDefaultAsync();

        if (product == null)
        {
            return NotFound($"Product with ID {id} not found");
        }

        return Ok(product);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> PutTProducts(int id, ProductDto productDto)
    {
        if (id <= 0)
        {
            return BadRequest("Invalid product ID");
        }

        if (productDto == null)
        {
            return BadRequest("Product data is required");
        }

        if (id != productDto.Id)
        {
            return BadRequest("ID mismatch between URL and request body");
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        var existingProduct = await _context.TProducts.FindAsync(id);
        if (existingProduct == null)
        {
            return NotFound($"Product with ID {id} not found");
        }

        if (productDto.ProductTypeId.HasValue)
        {
            var productTypeExists = await _context.TProductTypes.AnyAsync(pt => pt.Id == productDto.ProductTypeId);
            if (!productTypeExists)
            {
                return BadRequest("Invalid ProductTypeId - Product type does not exist");
            }
        }

        existingProduct.Name = productDto.Name;
        existingProduct.Icon = productDto.Icon;
        existingProduct.PurchasePrice = productDto.PurchasePrice;
        existingProduct.SellingPrice = productDto.SellingPrice;
        existingProduct.Count = productDto.Count;
        existingProduct.ProductTypeId = productDto.ProductTypeId;

        try
        {
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!TProductsExists(id))
            {
                return NotFound($"Product with ID {id} was deleted by another user");
            }
            else
            {
                throw;
            }
        }

        return NoContent();
    }

    [HttpPost]
    public async Task<ActionResult<TProducts>> PostTProducts(ProductDto productDto)
    {
        if (productDto == null)
        {
            return BadRequest("Product data is required");
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        if (productDto.ProductTypeId.HasValue)
        {
            var productTypeExists = await _context.TProductTypes.AnyAsync(pt => pt.Id == productDto.ProductTypeId);
            if (!productTypeExists)
            {
                return BadRequest("Invalid ProductTypeId - Product type does not exist");
            }
        }

        var product = new TProducts
        {
            Name = productDto.Name,
            Icon = productDto.Icon,
            PurchasePrice = productDto.PurchasePrice,
            SellingPrice = productDto.SellingPrice,
            Count = productDto.Count ?? 0,
            ProductTypeId = productDto.ProductTypeId
        };

        _context.TProducts.Add(product);
        await _context.SaveChangesAsync();

        return CreatedAtAction(nameof(GetTProducts), new { id = product.Id }, product);
    }

    [HttpPost("{id}/stock/add")]
    public async Task<IActionResult> AddStock(int id, ProductStockDto stockDto)
    {
        if (id <= 0)
        {
            return BadRequest("Invalid product ID");
        }

        if (stockDto == null)
        {
            return BadRequest("Stock data is required");
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        if (stockDto.Quantity <= 0)
        {
            return BadRequest("Quantity must be greater than zero");
        }

        var product = await _context.TProducts.FindAsync(id);
        if (product == null)
        {
            return NotFound($"Product with ID {id} not found");
        }

        var currentStock = product.Count ?? 0;
        if (currentStock > int.MaxValue - stockDto.Quantity)
        {
            return BadRequest("Stock overflow - resulting quantity would be too large");
        }

        product.Count = currentStock + stockDto.Quantity;
        await _context.SaveChangesAsync();

        return Ok(new { Message = "Stock added successfully", NewCount = product.Count });
    }

    [HttpPost("{id}/stock/remove")]
    public async Task<IActionResult> RemoveStock(int id, ProductStockDto stockDto)
    {
        if (id <= 0)
        {
            return BadRequest("Invalid product ID");
        }

        if (stockDto == null)
        {
            return BadRequest("Stock data is required");
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        if (stockDto.Quantity <= 0)
        {
            return BadRequest("Quantity must be greater than zero");
        }

        var product = await _context.TProducts.FindAsync(id);
        if (product == null)
        {
            return NotFound($"Product with ID {id} not found");
        }

        var currentStock = product.Count ?? 0;
        if (currentStock < stockDto.Quantity)
        {
            return BadRequest($"Insufficient stock. Current stock: {currentStock}, Requested: {stockDto.Quantity}");
        }

        product.Count = currentStock - stockDto.Quantity;
        await _context.SaveChangesAsync();

        return Ok(new { Message = "Stock removed successfully", NewCount = product.Count });
    }

    [HttpPost("bulk-update-prices")]
    public async Task<IActionResult> BulkUpdatePrices([FromBody] Dictionary<int, int> priceUpdates, [FromQuery] bool isPurchasePrice = false)
    {
        if (priceUpdates == null || !priceUpdates.Any())
        {
            return BadRequest("Price updates data is required");
        }

        var invalidPrices = priceUpdates.Where(p => p.Value < 0).ToList();
        if (invalidPrices.Any())
        {
            return BadRequest("Prices cannot be negative");
        }

        var productIds = priceUpdates.Keys.ToList();
        var products = await _context.TProducts
            .Where(p => productIds.Contains(p.Id))
            .ToListAsync();

        if (!products.Any())
        {
            return NotFound("No products found with the provided IDs");
        }

        var updatedCount = 0;
        foreach (var product in products)
        {
            if (priceUpdates.ContainsKey(product.Id))
            {
                if (isPurchasePrice)
                    product.PurchasePrice = priceUpdates[product.Id];
                else
                    product.SellingPrice = priceUpdates[product.Id];
                updatedCount++;
            }
        }

        await _context.SaveChangesAsync();
        return Ok(new { Message = $"{updatedCount} products updated successfully" });
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteTProducts(int id)
    {
        if (id <= 0)
        {
            return BadRequest("Invalid product ID");
        }

        var product = await _context.TProducts
            .Include(p => p.OrderDetails)
            .FirstOrDefaultAsync(p => p.Id == id);

        if (product == null)
        {
            return NotFound($"Product with ID {id} not found");
        }

        if (product.OrderDetails?.Any() == true)
        {
            return BadRequest("Cannot delete product that has order history. Consider deactivating instead.");
        }

        _context.TProducts.Remove(product);
        await _context.SaveChangesAsync();

        return NoContent();
    }

    private bool TProductsExists(int id)
    {
        return _context.TProducts.Any(e => e.Id == id);
    }
}


namespace MainApi.Controllers.Product;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class ProductTypesController : ControllerBase
{
    private readonly MechanicContext _context;

    public ProductTypesController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<object>>> GetTProductTypes([FromQuery] string? search = null)
    {
        var query = _context.TProductTypes.Include(pt => pt.Products).AsQueryable();

        if (!string.IsNullOrEmpty(search))
        {
            query = query.Where(pt => pt.Name.Contains(search));
        }

        var productTypes = await query
            .Select(pt => new
            {
                pt.Id,
                pt.Name,
                pt.Icon,
                ProductCount = pt.Products != null ? pt.Products.Count : 0,
                TotalValue = pt.Products != null ? pt.Products.Sum(p => (p.Count ?? 0) * (p.PurchasePrice ?? 0)) : 0
            })
            .OrderBy(pt => pt.Name)
            .ToListAsync();

        return Ok(productTypes);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<object>> GetTProductTypes(int id)
    {
        var productType = await _context.TProductTypes
            .Include(pt => pt.Products)
            .Where(pt => pt.Id == id)
            .Select(pt => new
            {
                pt.Id,
                pt.Name,
                pt.Icon,
                Products = pt.Products.Select(p => new
                {
                    p.Id,
                    p.Name,
                    p.Count,
                    p.SellingPrice
                }).ToList(),
                ProductCount = pt.Products.Count,
                TotalValue = pt.Products.Sum(p => (p.Count ?? 0) * (p.PurchasePrice ?? 0))
            })
            .FirstOrDefaultAsync();

        if (productType == null)
        {
            return NotFound();
        }

        return Ok(productType);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> PutTProductTypes(int id, ProductTypeDto productTypeDto)
    {
        if (id != productTypeDto.Id)
        {
            return BadRequest();
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        var existingProductType = await _context.TProductTypes.FindAsync(id);
        if (existingProductType == null)
        {
            return NotFound();
        }

        var duplicateExists = await _context.TProductTypes
            .AnyAsync(pt => pt.Name == productTypeDto.Name && pt.Id != id);

        if (duplicateExists)
        {
            return BadRequest("Product type with this name already exists");
        }

        existingProductType.Name = productTypeDto.Name;
        existingProductType.Icon = productTypeDto.Icon;

        try
        {
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!TProductTypesExists(id))
            {
                return NotFound();
            }
            else
            {
                throw;
            }
        }

        return NoContent();
    }

    [HttpPost]
    public async Task<ActionResult<TProductTypes>> PostTProductTypes(ProductTypeDto productTypeDto)
    {
        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        var duplicateExists = await _context.TProductTypes
            .AnyAsync(pt => pt.Name == productTypeDto.Name);

        if (duplicateExists)
        {
            return BadRequest("Product type with this name already exists");
        }

        var productType = new TProductTypes
        {
            Name = productTypeDto.Name,
            Icon = productTypeDto.Icon
        };

        _context.TProductTypes.Add(productType);
        await _context.SaveChangesAsync();

        return CreatedAtAction("GetTProductTypes", new { id = productType.Id }, productType);
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteTProductTypes(int id)
    {
        var productType = await _context.TProductTypes
            .Include(pt => pt.Products)
            .FirstOrDefaultAsync(pt => pt.Id == id);

        if (productType == null)
        {
            return NotFound();
        }

        if (productType.Products?.Any() == true)
        {
            return BadRequest("Cannot delete product type that has associated products");
        }

        _context.TProductTypes.Remove(productType);
        await _context.SaveChangesAsync();

        return NoContent();
    }

    private bool TProductTypesExists(int id)
    {
        return _context.TProductTypes.Any(e => e.Id == id);
    }
}


namespace MainApi.Controllers.User;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class UsersController : ControllerBase
{
    private readonly MechanicContext _context;
    private readonly IConfiguration _configuration;

    public UsersController(MechanicContext context, IConfiguration configuration)
    {
        _context = context;
        _configuration = configuration;
    }

    [HttpGet]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<IEnumerable<UserProfileDto>>> GetUsers()
    {
        return await _context.TUsers
            .Where(u => u.IsActive)
            .Select(u => new UserProfileDto
            {
                Id = u.Id,
                PhoneNumber = u.PhoneNumber,
                CreatedAt = u.CreatedAt
            })
            .ToListAsync();
    }

    [HttpGet("{id}")]
    [Authorize]
    public async Task<ActionResult<UserProfileDto>> GetUser(int id)
    {
        var user = await _context.TUsers
            .Where(u => u.Id == id && u.IsActive)
            .Select(u => new UserProfileDto
            {
                Id = u.Id,
                PhoneNumber = u.PhoneNumber,
                CreatedAt = u.CreatedAt
            })
            .FirstOrDefaultAsync();
        if (user == null)
            return NotFound();

        return user;
    }

    [HttpGet("profile")]
    [Authorize]
    public async Task<ActionResult<UserProfileDto>> GetProfile()
    {
        var userId = GetCurrentUserId();
        if (userId == null)
            return Unauthorized();
        var user = await _context.TUsers
            .Where(u => u.Id == userId && u.IsActive)
            .Select(u => new UserProfileDto
            {
                Id = u.Id,
                PhoneNumber = u.PhoneNumber,
                CreatedAt = u.CreatedAt
            })
            .FirstOrDefaultAsync();
        if (user == null)
            return NotFound();

        return user;
    }

    [HttpPost]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<UserProfileDto>> CreateUser([FromBody] TUsers tUsers)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        if (string.IsNullOrWhiteSpace(tUsers.PhoneNumber))
            return BadRequest("Phone number is required.");
        if (await _context.TUsers.AnyAsync(u => u.PhoneNumber == tUsers.PhoneNumber))
            return Conflict("User with this phone number already exists.");
        tUsers.CreatedAt = DateTime.UtcNow;
        _context.TUsers.Add(tUsers);
        await _context.SaveChangesAsync();

        var dto = new UserProfileDto
        {
            Id = tUsers.Id,
            PhoneNumber = tUsers.PhoneNumber,
            CreatedAt = tUsers.CreatedAt
        };
        return CreatedAtAction(nameof(GetUser), new { id = dto.Id }, dto);
    }

    [HttpPut("{id}")]
    [Authorize]
    public async Task<IActionResult> UpdateUser(int id, [FromBody] TUsers tUsers)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        if (id != tUsers.Id)
            return BadRequest("ID mismatch");
        var existingUser = await _context.TUsers.FindAsync(id);
        if (existingUser == null || !existingUser.IsActive)
            return NotFound();
        var currentUserId = GetCurrentUserId();
        if (currentUserId != id)
            return Forbid();
        existingUser.FirstName = tUsers.FirstName;
        existingUser.LastName = tUsers.LastName;

        try
        {
            _context.Entry(existingUser).State = EntityState.Modified;
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!await _context.TUsers.AnyAsync(u => u.Id == id))
                return NotFound();
            throw;
        }

        return NoContent();
    }

    [HttpPatch("{id}/status")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> ChangeUserStatus(int id, [FromBody] bool isActive)
    {
        var user = await _context.TUsers.FindAsync(id);
        if (user == null)
            return NotFound();

        user.IsActive = isActive;
        await _context.SaveChangesAsync();

        return NoContent();
    }

    [HttpDelete("{id}")]
    [Authorize]
    public async Task<IActionResult> DeleteUser(int id)
    {
        var user = await _context.TUsers.FindAsync(id);
        if (user == null)
            return NotFound();

        user.IsActive = false;
        await _context.SaveChangesAsync();

        return NoContent();
    }


    [HttpPost("login")]
    [AllowAnonymous]
    public async Task<IActionResult> Login([FromBody] LoginRequestDto request)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        var user = await _context.TUsers.FirstOrDefaultAsync(u => u.PhoneNumber == request.PhoneNumber);

        if (user == null)
        {
            user = new TUsers
            {
                PhoneNumber = request.PhoneNumber,
                CreatedAt = DateTime.UtcNow,
                IsActive = true
            };
            _context.TUsers.Add(user);
            await _context.SaveChangesAsync();
        }

        if (!user.IsActive)
            return Unauthorized("Invalid credentials.");
        var otp = GenerateOtp();

        var existingOtps = _context.TUserOtps.Where(o => o.UserId == user.Id && !o.IsUsed);
        _context.TUserOtps.RemoveRange(existingOtps);
        var userOtp = new TUserOtp
        {
            UserId = user.Id,
            OtpHash = BCrypt.Net.BCrypt.HashPassword(otp),
            ExpiresAt = DateTime.UtcNow.AddMinutes(5)
        };
        _context.TUserOtps.Add(userOtp);
        await _context.SaveChangesAsync();

        var apiKey = _configuration["Kavenegar:ApiKey"];
        var sender = _configuration["Kavenegar:SenderNumber"];
        var receptor = request.PhoneNumber;
        var message = $"Verification code : {otp}";
        var template = "verify";

        var api = new KavenegarApi(apiKey);

        api.VerifyLookup(receptor, otp, template);
        return Ok(new { Message = "OTP sent successfully" });
    }

    [HttpPost("verify-otp")]
    [AllowAnonymous]
    public async Task<ActionResult<AuthResponseDto>> VerifyOtp([FromBody] VerifyOtpRequestDto request)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        var user = await _context.TUsers.FirstOrDefaultAsync(u => u.PhoneNumber == request.PhoneNumber && u.IsActive);
        if (user == null)
            return BadRequest("Invalid credentials.");
        var storedOtp = await _context.TUserOtps.FirstOrDefaultAsync(o => o.UserId == user.Id && !o.IsUsed);

        if (storedOtp == null || storedOtp.ExpiresAt <= DateTime.UtcNow || storedOtp.AttemptCount >= 5)
            return BadRequest("Invalid or expired OTP code.");

        if (!BCrypt.Net.BCrypt.Verify(request.Code, storedOtp.OtpHash))
        {
            storedOtp.AttemptCount++;
            await _context.SaveChangesAsync();
            return BadRequest("Invalid credentials.");
        }

        storedOtp.IsUsed = true;
        await _context.SaveChangesAsync();

        var token = GenerateJwtToken(user);
        var refreshTokenValue = Guid.NewGuid().ToString("N");
        var refreshToken = new TRefreshToken
        {
            UserId = user.Id,
            TokenHash = BCrypt.Net.BCrypt.HashPassword(refreshTokenValue),
            ExpiresAt = DateTime.UtcNow.AddDays(7),
            CreatedAt = DateTime.UtcNow,
            CreatedByIp = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "",
            UserAgent = Request.Headers["User-Agent"].ToString()
        };
        _context.Set<TRefreshToken>().Add(refreshToken);
        await _context.SaveChangesAsync();

        var response = new AuthResponseDto
        {
            Token = token,
            User = new UserProfileDto { Id = user.Id, PhoneNumber = user.PhoneNumber, CreatedAt = user.CreatedAt },
            ExpiresAt = DateTime.UtcNow.AddHours(24),
            RefreshToken = refreshTokenValue
        };
        return Ok(response);
    }

    [HttpPost("refresh")]
    [AllowAnonymous]
    public async Task<IActionResult> Refresh([FromBody] RefreshRequestDto request)
    {
        var refreshTokenValue = request.RefreshToken;
        if (string.IsNullOrWhiteSpace(refreshTokenValue))
            return BadRequest("Refresh token is required.");

        var activeRefreshTokens = await _context.TRefreshToken
            .Include(rt => rt.User)
            .Where(rt => rt.ExpiresAt > DateTime.UtcNow && rt.RevokedAt == null)
            .ToListAsync();

        TRefreshToken? matchingToken = null;
        foreach (var token in activeRefreshTokens)
        {
            if (BCrypt.Net.BCrypt.Verify(refreshTokenValue, token.TokenHash))
            {
                matchingToken = token;
                break;
            }
        }

        if (matchingToken == null || matchingToken.User == null || !matchingToken.User.IsActive)
            return BadRequest("Invalid or expired refresh token.");

        var newRefreshTokenValue = Guid.NewGuid().ToString("N");
        var newRefreshToken = new TRefreshToken
        {
            UserId = matchingToken.UserId,
            TokenHash = BCrypt.Net.BCrypt.HashPassword(newRefreshTokenValue),
            ExpiresAt = DateTime.UtcNow.AddDays(7),
            CreatedAt = DateTime.UtcNow,
            CreatedByIp = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "",
            UserAgent = Request.Headers["User-Agent"].ToString()
        };

        matchingToken.RevokedAt = DateTime.UtcNow;
        matchingToken.ReplacedByTokenHash = newRefreshToken.TokenHash;

        _context.TRefreshToken.Add(newRefreshToken);
        await _context.SaveChangesAsync();

        var newJwtToken = GenerateJwtToken(matchingToken.User);

        return Ok(new AuthResponseDto
        {
            Token = newJwtToken,
            User = new UserProfileDto { Id = matchingToken.User.Id, PhoneNumber = matchingToken.User.PhoneNumber, CreatedAt = matchingToken.User.CreatedAt },
            ExpiresAt = DateTime.UtcNow.AddHours(24),
            RefreshToken = newRefreshTokenValue
        });
    }

    private string GenerateOtp()
    {
        var random = new Random();
        return random.Next(1000, 9999).ToString();
    }

    private string GenerateJwtToken(TUsers user)
    {
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Key"] ?? "00000000000000000000000000000000"));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var claims = new[]
        {
            new Claim("id", user.Id.ToString()),
            new Claim(ClaimTypes.MobilePhone, user.PhoneNumber),
            new Claim(ClaimTypes.Role, user.IsAdmin ? "Admin" : "User"),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };
        var token = new JwtSecurityToken(
            issuer: _configuration["Jwt:Issuer"] ?? "YourIssuer",
            audience: _configuration["Jwt:Audience"] ?? "YourAudience",
            claims: claims,
            expires: DateTime.UtcNow.AddHours(24),
            signingCredentials: creds
        );
        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    private int? GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst("id")?.Value;
        return int.TryParse(userIdClaim, out var userId) ? userId : null;
    }
}