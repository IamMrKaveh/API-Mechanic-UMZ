namespace MainApi.Services.Cart;

public interface ICartService
{
    Task<CartDto?> GetCartByUserIdAsync(int userId);
    Task<bool> AddItemToCartAsync(int userId, AddToCartDto dto);
    Task<bool> UpdateCartItemAsync(int userId, int itemId, UpdateCartItemDto dto);
    Task<bool> RemoveItemFromCartAsync(int userId, int itemId);
    Task<bool> ClearCartAsync(int userId);
    Task<int> GetCartItemsCountAsync(int userId);
}

public class CartService : ICartService
{
    private readonly MechanicContext _context;
    private readonly ILogger<CartService> _logger;

    public CartService(MechanicContext context, ILogger<CartService> logger)
    {
        _context = context;
        _logger = logger;
    }

    public async Task<CartDto?> GetCartByUserIdAsync(int userId)
    {
        try
        {
            var cart = await _context.TCarts
                .Include(c => c.CartItems)
                .ThenInclude(ci => ci.Product)
                .FirstOrDefaultAsync(c => c.UserId == userId);

            if (cart == null)
            {
                cart = new TCarts
                {
                    UserId = userId,
                    TotalItems = 0,
                    TotalPrice = 0
                };
                _context.TCarts.Add(cart);
                await _context.SaveChangesAsync();
            }

            return new CartDto
            {
                Id = cart.Id,
                UserId = cart.UserId,
                CartItems = cart.CartItems?.Select(ci => new CartItemDto
                {
                    Id = ci.Id,
                    ProductId = ci.ProductId,
                    ProductName = ci.Product?.Name ?? "",
                    SellingPrice = ci.Product?.SellingPrice ?? 0,
                    Quantity = ci.Quantity,
                    TotalPrice = (ci.Product?.SellingPrice ?? 0) * ci.Quantity
                }).ToList() ?? new List<CartItemDto>(),
                TotalItems = cart.TotalItems,
                TotalPrice = cart.TotalPrice
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving cart for user {UserId}", userId);
            return null;
        }
    }

    public async Task<bool> AddItemToCartAsync(int userId, AddToCartDto dto)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var cart = await GetOrCreateCartAsync(userId);

            var product = await _context.TProducts
                .FirstOrDefaultAsync(p => p.Id == dto.ProductId);

            if (product == null)
            {
                _logger.LogWarning("Product not found when adding to cart: ProductId {ProductId}, UserId {UserId}", dto.ProductId, userId);
                return false;
            }

            var currentStock = product.Count ?? 0;
            if (currentStock < dto.Quantity)
            {
                _logger.LogWarning("Insufficient stock when adding to cart: ProductId {ProductId}, Available {Available}, Requested {Requested}",
                    dto.ProductId, currentStock, dto.Quantity);
                return false;
            }

            var existingItem = cart.CartItems?.FirstOrDefault(ci => ci.ProductId == dto.ProductId);

            if (existingItem != null)
            {
                var newQuantity = existingItem.Quantity + dto.Quantity;
                if (newQuantity > currentStock)
                {
                    _logger.LogWarning("Insufficient stock for updated cart quantity: ProductId {ProductId}, Available {Available}, Requested {Requested}",
                        dto.ProductId, currentStock, newQuantity);
                    return false;
                }

                existingItem.Quantity = newQuantity;
                _context.TCartItems.Update(existingItem);
            }
            else
            {
                var cartItem = new TCartItems
                {
                    CartId = cart.Id,
                    ProductId = dto.ProductId,
                    Quantity = dto.Quantity
                };
                _context.TCartItems.Add(cartItem);
            }

            var reloadedProduct = await _context.TProducts
                .FirstOrDefaultAsync(p => p.Id == dto.ProductId);

            if (reloadedProduct == null || (reloadedProduct.Count ?? 0) < dto.Quantity)
            {
                _logger.LogWarning("Stock changed during cart operation: ProductId {ProductId}, UserId {UserId}", dto.ProductId, userId);
                return false;
            }

            await UpdateCartTotalsAsync(cart);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            _logger.LogInformation("Added item to cart: ProductId {ProductId}, Quantity {Quantity}, UserId {UserId}",
                dto.ProductId, dto.Quantity, userId);

            return true;
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Error adding item to cart: ProductId {ProductId}, UserId {UserId}", dto.ProductId, userId);
            return false;
        }
    }

    public async Task<bool> UpdateCartItemAsync(int userId, int itemId, UpdateCartItemDto dto)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var cartItem = await _context.TCartItems
                .Include(ci => ci.Cart)
                .Include(ci => ci.Product)
                .FirstOrDefaultAsync(ci => ci.Id == itemId && ci.Cart.UserId == userId);

            if (cartItem == null)
            {
                _logger.LogWarning("Cart item not found: ItemId {ItemId}, UserId {UserId}", itemId, userId);
                return false;
            }

            var product = await _context.TProducts
                .FirstOrDefaultAsync(p => p.Id == cartItem.ProductId);

            if (product == null || dto.Quantity > (product.Count ?? 0))
            {
                _logger.LogWarning("Insufficient stock for cart item update: ItemId {ItemId}, Available {Available}, Requested {Requested}",
                    itemId, product?.Count ?? 0, dto.Quantity);
                return false;
            }

            cartItem.Quantity = dto.Quantity;
            _context.TCartItems.Update(cartItem);

            await UpdateCartTotalsAsync(cartItem.Cart);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            _logger.LogInformation("Updated cart item: ItemId {ItemId}, Quantity {Quantity}, UserId {UserId}",
                itemId, dto.Quantity, userId);

            return true;
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Error updating cart item: ItemId {ItemId}, UserId {UserId}", itemId, userId);
            return false;
        }
    }

    public async Task<bool> RemoveItemFromCartAsync(int userId, int itemId)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var cartItem = await _context.TCartItems
                .Include(ci => ci.Cart)
                .FirstOrDefaultAsync(ci => ci.Id == itemId && ci.Cart.UserId == userId);

            if (cartItem == null)
            {
                _logger.LogWarning("Cart item not found for removal: ItemId {ItemId}, UserId {UserId}", itemId, userId);
                return false;
            }

            _context.TCartItems.Remove(cartItem);
            await UpdateCartTotalsAsync(cartItem.Cart);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            _logger.LogInformation("Removed cart item: ItemId {ItemId}, UserId {UserId}", itemId, userId);

            return true;
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Error removing cart item: ItemId {ItemId}, UserId {UserId}", itemId, userId);
            return false;
        }
    }

    public async Task<bool> ClearCartAsync(int userId)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var cart = await _context.TCarts
                .Include(c => c.CartItems)
                .FirstOrDefaultAsync(c => c.UserId == userId);

            if (cart == null || !cart.CartItems.Any())
            {
                _logger.LogInformation("Cart already empty or not found: UserId {UserId}", userId);
                return true;
            }

            _context.TCartItems.RemoveRange(cart.CartItems);
            cart.TotalItems = 0;
            cart.TotalPrice = 0;
            _context.TCarts.Update(cart);

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            _logger.LogInformation("Cleared cart: UserId {UserId}", userId);

            return true;
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Error clearing cart: UserId {UserId}", userId);
            return false;
        }
    }

    public async Task<int> GetCartItemsCountAsync(int userId)
    {
        try
        {
            return await _context.TCarts
                .Where(c => c.UserId == userId)
                .Select(c => c.TotalItems)
                .FirstOrDefaultAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting cart items count: UserId {UserId}", userId);
            return 0;
        }
    }

    private async Task<TCarts> GetOrCreateCartAsync(int userId)
    {
        var cart = await _context.TCarts
            .Include(c => c.CartItems)
            .FirstOrDefaultAsync(c => c.UserId == userId);

        if (cart == null)
        {
            cart = new TCarts { UserId = userId, TotalItems = 0, TotalPrice = 0 };
            _context.TCarts.Add(cart);
            await _context.SaveChangesAsync();
        }

        return cart;
    }

    private async Task UpdateCartTotalsAsync(TCarts cart)
    {
        var cartItems = await _context.TCartItems
            .Include(ci => ci.Product)
            .Where(ci => ci.CartId == cart.Id)
            .ToListAsync();

        cart.TotalItems = cartItems.Sum(ci => ci.Quantity);
        cart.TotalPrice = cartItems.Sum(ci => (ci.Product?.SellingPrice ?? 0) * ci.Quantity);
        _context.TCarts.Update(cart);
    }
}


namespace MainApi.Controllers.Cart;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class CartItemsController : ControllerBase
{
    private readonly MechanicContext _context;
    private readonly ILogger<CartItemsController> _logger;

    public CartItemsController(MechanicContext context, ILogger<CartItemsController> logger)
    {
        _context = context;
        _logger = logger;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<CartItemDto>>> GetCartItems()
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        try
        {
            var cartItems = await _context.TCartItems
                .Include(ci => ci.Product)
                .Include(ci => ci.Cart)
                .Where(ci => ci.Cart!.UserId == userId)
                .Select(ci => new CartItemDto
                {
                    Id = ci.Id,
                    ProductId = ci.ProductId,
                    ProductName = ci.Product!.Name ?? "",
                    SellingPrice = ci.Product.SellingPrice ?? 0,
                    Quantity = ci.Quantity,
                    TotalPrice = (ci.Product.SellingPrice ?? 0) * ci.Quantity
                })
                .ToListAsync();

            return Ok(cartItems);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving cart items for user {UserId}", userId);
            return StatusCode(500, "An error occurred while retrieving cart items");
        }
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<CartItemDto>> GetCartItem(int id)
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        try
        {
            var cartItem = await _context.TCartItems
                .Include(ci => ci.Product)
                .Include(ci => ci.Cart)
                .Where(ci => ci.Id == id && ci.Cart!.UserId == userId)
                .Select(ci => new CartItemDto
                {
                    Id = ci.Id,
                    ProductId = ci.ProductId,
                    ProductName = ci.Product!.Name ?? "",
                    SellingPrice = ci.Product.SellingPrice ?? 0,
                    Quantity = ci.Quantity,
                    TotalPrice = (ci.Product.SellingPrice ?? 0) * ci.Quantity
                })
                .FirstOrDefaultAsync();

            if (cartItem == null)
                return NotFound("Cart item not found");

            return Ok(cartItem);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving cart item {ItemId} for user {UserId}", id, userId);
            return StatusCode(500, "An error occurred while retrieving cart item");
        }
    }

    [HttpPost]
    public async Task<ActionResult<CartItemDto>> CreateCartItem([FromBody] AddToCartDto addToCartDto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        if (addToCartDto.Quantity > 1000)
            return BadRequest("Quantity cannot exceed 1000");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var product = await _context.TProducts
                .FirstOrDefaultAsync(p => p.Id == addToCartDto.ProductId);

            if (product == null)
            {
                await transaction.RollbackAsync();
                return NotFound("Product not found");
            }

            var currentStock = product.Count ?? 0;
            if (currentStock < addToCartDto.Quantity)
            {
                await transaction.RollbackAsync();
                return BadRequest($"Not enough stock available. Current stock: {currentStock}");
            }

            var cart = await _context.TCarts
                .Include(c => c.CartItems)
                .FirstOrDefaultAsync(c => c.UserId == userId);

            if (cart == null)
            {
                cart = new TCarts
                {
                    UserId = userId,
                    TotalItems = 0,
                    TotalPrice = 0
                };
                _context.TCarts.Add(cart);
                await _context.SaveChangesAsync();
            }

            var existingCartItem = cart.CartItems.FirstOrDefault(ci => ci.ProductId == addToCartDto.ProductId);

            if (existingCartItem != null)
            {
                var newQuantity = existingCartItem.Quantity + addToCartDto.Quantity;
                if (currentStock < newQuantity)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Not enough stock available for updated quantity. Current stock: {currentStock}");
                }
                existingCartItem.Quantity = newQuantity;
                _context.TCartItems.Update(existingCartItem);
            }
            else
            {
                existingCartItem = new TCartItems
                {
                    CartId = cart.Id,
                    ProductId = addToCartDto.ProductId,
                    Quantity = addToCartDto.Quantity
                };
                _context.TCartItems.Add(existingCartItem);
            }

            var reloadedProduct = await _context.TProducts
                .FirstOrDefaultAsync(p => p.Id == addToCartDto.ProductId);

            if (reloadedProduct == null || (reloadedProduct.Count ?? 0) < (existingCartItem.Quantity))
            {
                await transaction.RollbackAsync();
                return BadRequest($"Stock changed during operation. Please try again.");
            }

            await UpdateCartTotalsAsync(cart.Id);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            var cartItemDto = new CartItemDto
            {
                Id = existingCartItem.Id,
                ProductId = existingCartItem.ProductId,
                ProductName = product.Name ?? "",
                SellingPrice = product.SellingPrice ?? 0,
                Quantity = existingCartItem.Quantity,
                TotalPrice = (product.SellingPrice ?? 0) * existingCartItem.Quantity
            };

            _logger.LogInformation("Added item to cart: ProductId {ProductId}, Quantity {Quantity}, UserId {UserId}",
                addToCartDto.ProductId, addToCartDto.Quantity, userId);

            return CreatedAtAction(nameof(GetCartItem), new { id = existingCartItem.Id }, cartItemDto);
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Error adding item to cart: ProductId {ProductId}, UserId {UserId}", addToCartDto.ProductId, userId);
            return StatusCode(500, "An error occurred while adding item to cart");
        }
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateCartItem(int id, [FromBody] UpdateCartItemDto updateCartItemDto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        if (updateCartItemDto.Quantity > 1000)
            return BadRequest("Quantity cannot exceed 1000");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var cartItem = await _context.TCartItems
                .Include(ci => ci.Cart)
                .Include(ci => ci.Product)
                .FirstOrDefaultAsync(ci => ci.Id == id && ci.Cart!.UserId == userId);

            if (cartItem == null)
            {
                await transaction.RollbackAsync();
                return NotFound("Cart item not found");
            }

            var product = await _context.TProducts
                .FirstOrDefaultAsync(p => p.Id == cartItem.ProductId);

            if (product == null || (product.Count ?? 0) < updateCartItemDto.Quantity)
            {
                await transaction.RollbackAsync();
                return BadRequest($"Not enough stock available. Current stock: {product?.Count ?? 0}");
            }

            cartItem.Quantity = updateCartItemDto.Quantity;
            _context.TCartItems.Update(cartItem);

            await UpdateCartTotalsAsync(cartItem.CartId);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            _logger.LogInformation("Updated cart item: ItemId {ItemId}, Quantity {Quantity}, UserId {UserId}",
                id, updateCartItemDto.Quantity, userId);

            return NoContent();
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Error updating cart item: ItemId {ItemId}, UserId {UserId}", id, userId);
            return StatusCode(500, "An error occurred while updating cart item");
        }
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteCartItem(int id)
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var cartItem = await _context.TCartItems
                .Include(ci => ci.Cart)
                .FirstOrDefaultAsync(ci => ci.Id == id && ci.Cart!.UserId == userId);

            if (cartItem == null)
            {
                await transaction.RollbackAsync();
                return NotFound("Cart item not found");
            }

            var cartId = cartItem.CartId;
            _context.TCartItems.Remove(cartItem);

            await UpdateCartTotalsAsync(cartId);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            _logger.LogInformation("Deleted cart item: ItemId {ItemId}, UserId {UserId}", id, userId);

            return NoContent();
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Error deleting cart item: ItemId {ItemId}, UserId {UserId}", id, userId);
            return StatusCode(500, "An error occurred while deleting cart item");
        }
    }

    [HttpDelete("clear")]
    public async Task<IActionResult> ClearCart()
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var cart = await _context.TCarts
                .Include(c => c.CartItems)
                .FirstOrDefaultAsync(c => c.UserId == userId);

            if (cart == null)
            {
                await transaction.RollbackAsync();
                return NotFound("Cart not found");
            }

            _context.TCartItems.RemoveRange(cart.CartItems);
            cart.TotalItems = 0;
            cart.TotalPrice = 0;

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            _logger.LogInformation("Cleared cart for user {UserId}", userId);

            return NoContent();
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Error clearing cart for user {UserId}", userId);
            return StatusCode(500, "An error occurred while clearing cart");
        }
    }

    [NonAction]
    private async Task UpdateCartTotalsAsync(int cartId)
    {
        var cart = await _context.TCarts
            .Include(c => c.CartItems)
            .ThenInclude(ci => ci.Product)
            .FirstOrDefaultAsync(c => c.Id == cartId);

        if (cart != null)
        {
            cart.TotalItems = cart.CartItems.Sum(ci => ci.Quantity);
            cart.TotalPrice = cart.CartItems.Sum(ci => (ci.Product!.SellingPrice ?? 0) * ci.Quantity);
            _context.TCarts.Update(cart);
        }
    }

    [NonAction]
    private int GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst("id")?.Value;
        if (string.IsNullOrEmpty(userIdClaim) || !int.TryParse(userIdClaim, out int userId))
            return 0;
        return userId;
    }
}


namespace MainApi.Controllers.Cart;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class CartsController : ControllerBase
{
    private readonly ICartService _cartService;

    public CartsController(ICartService cartService)
    {
        _cartService = cartService;
    }

    [HttpGet("my-cart")]
    public async Task<ActionResult<CartDto>> GetMyCart()
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        var cart = await _cartService.GetCartByUserIdAsync(userId);
        return Ok(cart);
    }

    [HttpPost("add-item")]
    public async Task<ActionResult> AddToCart([FromBody] AddToCartDto dto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");
        var result = await _cartService.AddItemToCartAsync(userId, dto);
        if (!result)
            return BadRequest("Unable to add item to cart. Check product availability or stock.");
        return Ok(new { Message = "Item added to cart successfully" });
    }

    [HttpPut("update-item/{itemId}")]
    public async Task<ActionResult> UpdateCartItem(int itemId, [FromBody] UpdateCartItemDto dto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");
        var result = await _cartService.UpdateCartItemAsync(userId, itemId, dto);
        if (!result)
            return BadRequest("Unable to update cart item. Check quantity or item existence.");
        return Ok(new { Message = "Cart item updated successfully" });
    }

    [HttpDelete("remove-item/{itemId}")]
    public async Task<ActionResult> RemoveFromCart(int itemId)
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");
        var result = await _cartService.RemoveItemFromCartAsync(userId, itemId);
        if (!result)
            return NotFound("Cart item not found");
        return Ok(new { Message = "Item removed from cart successfully" });
    }

    [HttpDelete("clear")]
    public async Task<ActionResult> ClearCart()
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");

        await _cartService.ClearCartAsync(userId);
        return Ok(new { Message = "Cart cleared successfully" });
    }

    [HttpGet("count")]
    public async Task<ActionResult<int>> GetCartItemsCount()
    {
        var userId = GetCurrentUserId();
        if (userId == 0)
            return Unauthorized("Invalid user");
        var count = await _cartService.GetCartItemsCountAsync(userId);
        return Ok(count);
    }

    [NonAction]
    private int GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst("id")?.Value;
        if (string.IsNullOrEmpty(userIdClaim) || !int.TryParse(userIdClaim, out int userId))
            return 0;
        return userId;
    }
}


namespace MainApi.Controllers.Order;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class OrderItemsController : ControllerBase
{
    private readonly MechanicContext _context;

    public OrderItemsController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<object>>> GetOrderItems([FromQuery] int? orderId = null)
    {
        var query = _context.TOrderItems
            .Include(oi => oi.Product)
                .ThenInclude(p => p.ProductType)
            .Include(oi => oi.UserOrder)
            .AsQueryable();

        if (orderId.HasValue)
        {
            if (orderId.Value <= 0)
                return BadRequest("شناسه سفارش نامعتبر است");

            query = query.Where(oi => oi.UserOrderId == orderId.Value);
        }

        var orderItems = await query
            .Select(oi => new
            {
                oi.Id,
                oi.PurchasePrice,
                oi.SellingPrice,
                oi.Quantity,
                oi.Amount,
                oi.Profit,
                Product = new
                {
                    oi.Product.Id,
                    oi.Product.Name,
                    oi.Product.Icon,
                    ProductType = oi.Product.ProductType != null ? new
                    {
                        oi.Product.ProductType.Id,
                        oi.Product.ProductType.Name
                    } : null
                },
                Order = new
                {
                    oi.UserOrder.Id,
                    oi.UserOrder.Name,
                    oi.UserOrder.CreatedAt
                }
            })
            .OrderByDescending(oi => oi.Id)
            .ToListAsync();

        return Ok(orderItems);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<object>> GetOrderItem(int id)
    {
        if (id <= 0)
            return BadRequest("شناسه آیتم سفارش نامعتبر است");

        var orderItem = await _context.TOrderItems
            .Include(oi => oi.Product)
                .ThenInclude(p => p.ProductType)
            .Include(oi => oi.UserOrder)
                .ThenInclude(o => o.User)
            .Where(oi => oi.Id == id)
            .Select(oi => new
            {
                oi.Id,
                oi.PurchasePrice,
                oi.SellingPrice,
                oi.Quantity,
                oi.Amount,
                oi.Profit,
                Product = new
                {
                    oi.Product.Id,
                    oi.Product.Name,
                    oi.Product.Icon,
                    oi.Product.PurchasePrice,
                    oi.Product.SellingPrice,
                    oi.Product.Count,
                    ProductType = oi.Product.ProductType != null ? new
                    {
                        oi.Product.ProductType.Id,
                        oi.Product.ProductType.Name
                    } : null
                },
                Order = new
                {
                    oi.UserOrder.Id,
                    oi.UserOrder.Name,
                    oi.UserOrder.Address,
                    oi.UserOrder.CreatedAt,
                    User = new
                    {
                        oi.UserOrder.User.Id,
                        oi.UserOrder.User.PhoneNumber,
                        oi.UserOrder.User.FirstName,
                        oi.UserOrder.User.LastName
                    }
                }
            })
            .FirstOrDefaultAsync();

        if (orderItem == null)
            return NotFound("آیتم سفارش یافت نشد");

        return Ok(orderItem);
    }

    [HttpPost]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<TOrderItems>> CreateOrderItem(CreateOrderItemDto itemDto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        var order = await _context.TOrders.FindAsync(itemDto.UserOrderId);
        if (order == null)
            return BadRequest("سفارش یافت نشد");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var product = await _context.TProducts.FindAsync(itemDto.ProductId);
            if (product == null)
                return BadRequest("محصول یافت نشد");

            if ((product.Count ?? 0) < itemDto.Quantity)
                return BadRequest($"موجودی کافی نیست. موجودی: {product.Count ?? 0}, درخواستی: {itemDto.Quantity}");

            var orderItem = new TOrderItems
            {
                UserOrderId = itemDto.UserOrderId,
                ProductId = itemDto.ProductId,
                PurchasePrice = product.PurchasePrice ?? 0,
                SellingPrice = itemDto.SellingPrice,
                Quantity = itemDto.Quantity,
                Amount = itemDto.SellingPrice * itemDto.Quantity,
                Profit = (itemDto.SellingPrice - (product.PurchasePrice ?? 0)) * itemDto.Quantity
            };
            _context.TOrderItems.Add(orderItem);

            product.Count = (product.Count ?? 0) - itemDto.Quantity;
            _context.TProducts.Update(product);

            order.TotalAmount += orderItem.Amount;
            order.TotalProfit += orderItem.Profit;
            _context.TOrders.Update(order);

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return CreatedAtAction("GetOrderItem", new { id = orderItem.Id }, orderItem);
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            return StatusCode(500, "خطا در ایجاد آیتم سفارش");
        }
    }

    [HttpPut("{id}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> UpdateOrderItem(int id, UpdateOrderItemDto itemDto)
    {
        if (id <= 0)
            return BadRequest("شناسه آیتم سفارش نامعتبر است");

        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var orderItem = await _context.TOrderItems
                .Include(oi => oi.Product)
                .Include(oi => oi.UserOrder)
                .FirstOrDefaultAsync(oi => oi.Id == id);

            if (orderItem == null)
                return NotFound("آیتم سفارش یافت نشد");

            var oldAmount = orderItem.Amount;
            var oldProfit = orderItem.Profit;
            var oldQuantity = orderItem.Quantity;

            if (itemDto.Quantity.HasValue)
            {
                if (itemDto.Quantity.Value <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest("مقدار باید بیشتر از صفر باشد");
                }

                if (itemDto.Quantity.Value != oldQuantity)
                {
                    var quantityDifference = itemDto.Quantity.Value - oldQuantity;
                    var currentStock = orderItem.Product!.Count ?? 0;

                    if (currentStock < quantityDifference)
                    {
                        await transaction.RollbackAsync();
                        return BadRequest($"موجودی کافی نیست. موجودی: {currentStock}, نیاز اضافی: {quantityDifference}");
                    }

                    orderItem.Product.Count = currentStock - quantityDifference;
                    orderItem.Quantity = itemDto.Quantity.Value;
                    _context.TProducts.Update(orderItem.Product);
                }
            }

            if (itemDto.SellingPrice.HasValue)
            {
                if (itemDto.SellingPrice.Value <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest("قیمت فروش باید بیشتر از صفر باشد");
                }
                orderItem.SellingPrice = itemDto.SellingPrice.Value;
            }

            orderItem.Amount = orderItem.SellingPrice * orderItem.Quantity;
            orderItem.Profit = (orderItem.SellingPrice - orderItem.PurchasePrice) * orderItem.Quantity;

            orderItem.UserOrder!.TotalAmount = orderItem.UserOrder.TotalAmount - oldAmount + orderItem.Amount;
            orderItem.UserOrder.TotalProfit = orderItem.UserOrder.TotalProfit - oldProfit + orderItem.Profit;

            _context.TOrderItems.Update(orderItem);
            _context.TOrders.Update(orderItem.UserOrder);

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            await transaction.RollbackAsync();
            if (!await OrderItemExistsAsync(id))
                return NotFound("آیتم سفارش یافت نشد");
            return Conflict("داده‌ها توسط کاربر دیگری تغییر یافته است");
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            return StatusCode(500, "خطا در بروزرسانی آیتم سفارش");
        }
    }

    [HttpDelete("{id}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> DeleteOrderItem(int id)
    {
        if (id <= 0)
            return BadRequest("شناسه آیتم سفارش نامعتبر است");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var orderItem = await _context.TOrderItems
                .Include(oi => oi.Product)
                .Include(oi => oi.UserOrder)
                .FirstOrDefaultAsync(oi => oi.Id == id);

            if (orderItem == null)
                return NotFound("آیتم سفارش یافت نشد");

            if (orderItem.Product != null)
            {
                orderItem.Product.Count = (orderItem.Product.Count ?? 0) + orderItem.Quantity;
                _context.TProducts.Update(orderItem.Product);
            }

            orderItem.UserOrder!.TotalAmount -= orderItem.Amount;
            orderItem.UserOrder.TotalProfit -= orderItem.Profit;
            _context.TOrders.Update(orderItem.UserOrder);

            _context.TOrderItems.Remove(orderItem);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return NoContent();
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            return StatusCode(500, "خطا در حذف آیتم سفارش");
        }
    }

    [NonAction]
    private async Task<bool> OrderItemExistsAsync(int id)
    {
        return await _context.TOrderItems.AnyAsync(e => e.Id == id);
    }
}


namespace MainApi.Controllers.Order;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class OrdersController : ControllerBase
{
    private readonly MechanicContext _context;

    public OrdersController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<object>>> GetTOrders(
        [FromQuery] int? userId = null,
        [FromQuery] int? statusId = null,
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null,
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 10)
    {
        if (page < 1) page = 1;
        if (pageSize < 1 || pageSize > 100) pageSize = 10;

        var query = _context.TOrders
            .Include(o => o.User)
            .Include(o => o.OrderStatus)
            .Include(o => o.OrderItems)
                .ThenInclude(oi => oi.Product)
            .AsQueryable();

        if (userId.HasValue)
            query = query.Where(o => o.UserId == userId.Value);

        if (statusId.HasValue)
            query = query.Where(o => o.OrderStatusId == statusId.Value);

        if (fromDate.HasValue)
            query = query.Where(o => o.CreatedAt >= fromDate.Value);

        if (toDate.HasValue)
            query = query.Where(o => o.CreatedAt <= toDate.Value);

        var totalCount = await query.CountAsync();
        var orders = await query
            .OrderByDescending(o => o.CreatedAt)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .Select(o => new
            {
                o.Id,
                o.Name,
                o.Address,
                o.PostalCode,
                o.TotalAmount,
                o.TotalProfit,
                o.CreatedAt,
                o.DeliveryDate,
                User = new
                {
                    o.User!.Id,
                    o.User.PhoneNumber,
                    o.User.FirstName,
                    o.User.LastName
                },
                OrderStatus = new
                {
                    o.OrderStatus!.Id,
                    o.OrderStatus.Name,
                    o.OrderStatus.Icon
                },
                OrderItemsCount = o.OrderItems.Count
            })
            .ToListAsync();

        return Ok(new
        {
            Data = orders,
            TotalCount = totalCount,
            Page = page,
            PageSize = pageSize,
            TotalPages = (int)Math.Ceiling(totalCount / (double)pageSize)
        });
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<object>> GetOrderById(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order ID");

        var order = await _context.TOrders
            .Include(o => o.User)
            .Include(o => o.OrderStatus)
            .Include(o => o.OrderItems)
                .ThenInclude(oi => oi.Product)
                    .ThenInclude(p => p!.ProductType)
            .Where(o => o.Id == id)
            .Select(o => new
            {
                o.Id,
                o.Name,
                o.Address,
                o.PostalCode,
                o.TotalAmount,
                o.TotalProfit,
                o.CreatedAt,
                o.DeliveryDate,
                User = new
                {
                    o.User!.Id,
                    o.User.PhoneNumber,
                    o.User.FirstName,
                    o.User.LastName
                },
                OrderStatus = new
                {
                    o.OrderStatus!.Id,
                    o.OrderStatus.Name,
                    o.OrderStatus.Icon
                },
                OrderItems = o.OrderItems.Select(oi => new
                {
                    oi.Id,
                    oi.PurchasePrice,
                    oi.SellingPrice,
                    oi.Quantity,
                    oi.Amount,
                    oi.Profit,
                    Product = new
                    {
                        oi.Product!.Id,
                        oi.Product.Name,
                        oi.Product.Icon,
                        ProductType = oi.Product.ProductType != null ? new
                        {
                            oi.Product.ProductType.Id,
                            oi.Product.ProductType.Name
                        } : null
                    }
                })
            })
            .FirstOrDefaultAsync();

        if (order == null)
            return NotFound("Order not found");

        return Ok(order);
    }

    [HttpPost]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<TOrders>> PostTOrders(CreateOrderDto orderDto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        if (string.IsNullOrWhiteSpace(orderDto.Address) || string.IsNullOrWhiteSpace(orderDto.PostalCode))
            return BadRequest("Address and PostalCode are required");

        if (orderDto.OrderItems == null || !orderDto.OrderItems.Any())
            return BadRequest("At least one order item is required");

        var userExists = await _context.TUsers.AnyAsync(u => u.Id == orderDto.UserId);
        if (!userExists)
            return BadRequest("Invalid user ID");

        var statusExists = await _context.TOrderStatus.AnyAsync(s => s.Id == orderDto.OrderStatusId);
        if (!statusExists)
            return BadRequest("Invalid order status ID");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var productIds = orderDto.OrderItems.Select(i => i.ProductId).ToList();
            var products = await _context.TProducts
                .Where(p => productIds.Contains(p.Id))
                .ToDictionaryAsync(p => p.Id, p => p);

            var totalAmount = 0;
            var totalProfit = 0;

            foreach (var itemDto in orderDto.OrderItems)
            {
                if (!products.TryGetValue(itemDto.ProductId, out var product))
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {itemDto.ProductId} not found");
                }

                if ((product.Count ?? 0) < itemDto.Quantity)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {itemDto.ProductId} insufficient stock. Available: {product.Count ?? 0}, Requested: {itemDto.Quantity}");
                }

                product.Count = Math.Max(0, (product.Count ?? 0) - itemDto.Quantity);

                var amount = itemDto.SellingPrice * itemDto.Quantity;
                var profit = (itemDto.SellingPrice - (product.PurchasePrice ?? 0)) * itemDto.Quantity;

                totalAmount += amount;
                totalProfit += profit;
            }

            var order = new TOrders
            {
                UserId = orderDto.UserId,
                Name = orderDto.Name,
                Address = orderDto.Address,
                PostalCode = orderDto.PostalCode,
                CreatedAt = DateTime.UtcNow,
                OrderStatusId = orderDto.OrderStatusId,
                DeliveryDate = orderDto.DeliveryDate,
                TotalAmount = totalAmount,
                TotalProfit = totalProfit
            };

            _context.TOrders.Add(order);
            await _context.SaveChangesAsync();

            var orderItems = orderDto.OrderItems.Select(itemDto => new TOrderItems
            {
                UserOrderId = order.Id,
                ProductId = itemDto.ProductId,
                PurchasePrice = products[itemDto.ProductId].PurchasePrice ?? 0,
                SellingPrice = itemDto.SellingPrice,
                Quantity = itemDto.Quantity,
                Amount = itemDto.SellingPrice * itemDto.Quantity,
                Profit = (itemDto.SellingPrice - (products[itemDto.ProductId].PurchasePrice ?? 0)) * itemDto.Quantity
            }).ToList();

            _context.TOrderItems.AddRange(orderItems);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return CreatedAtAction(nameof(GetOrderById), new { id = order.Id }, order);
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            return StatusCode(500, $"An error occurred while creating the order: {ex.Message}");
        }
    }

    [HttpPost("checkout-from-cart")]
    public async Task<ActionResult<TOrders>> CheckoutFromCart([FromBody] CreateOrderDto orderDto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        if (string.IsNullOrWhiteSpace(orderDto.Address) || string.IsNullOrWhiteSpace(orderDto.PostalCode))
            return BadRequest("Address and PostalCode are required");

        var userId = GetCurrentUserId();
        if (!userId.HasValue)
            return Unauthorized("User not authenticated");

        var idempotencyKey = Request.Headers["Idempotency-Key"].FirstOrDefault();
        if (!string.IsNullOrEmpty(idempotencyKey))
        {
            var existingOrder = await _context.TOrders
                .FirstOrDefaultAsync(o => o.Name == idempotencyKey && o.UserId == userId.Value);
            if (existingOrder != null)
                return Conflict(new { Message = "Duplicate request", OrderId = existingOrder.Id });
        }

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var cart = await _context.TCarts
                .Include(c => c.CartItems)
                .ThenInclude(ci => ci.Product)
                .FirstOrDefaultAsync(c => c.UserId == userId.Value);

            if (cart == null || !cart.CartItems.Any())
            {
                await transaction.RollbackAsync();
                return BadRequest("Cart is empty");
            }

            var productUpdates = new List<TProducts>();
            var totalAmount = 0;
            var totalProfit = 0;
            var orderItems = new List<TOrderItems>();

            foreach (var item in cart.CartItems)
            {
                if (item.Quantity <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Invalid quantity for product {item.ProductId}");
                }

                var product = await _context.TProducts
                    .Where(p => p.Id == item.ProductId)
                    .FirstOrDefaultAsync();

                if (product == null)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {item.ProductId} not found");
                }

                if ((product.Count ?? 0) < item.Quantity)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {item.ProductId} insufficient stock. Available: {product.Count ?? 0}, Requested: {item.Quantity}");
                }

                if ((product.SellingPrice ?? 0) <= 0)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Product {item.ProductId} has invalid price");
                }

                product.Count = Math.Max(0, (product.Count ?? 0) - item.Quantity);
                productUpdates.Add(product);

                var orderItem = new TOrderItems
                {
                    ProductId = product.Id,
                    PurchasePrice = product.PurchasePrice ?? 0,
                    SellingPrice = product.SellingPrice ?? 0,
                    Quantity = item.Quantity,
                    Amount = (product.SellingPrice ?? 0) * item.Quantity,
                    Profit = ((product.SellingPrice ?? 0) - (product.PurchasePrice ?? 0)) * item.Quantity
                };

                totalAmount += orderItem.Amount;
                totalProfit += orderItem.Profit;
                orderItems.Add(orderItem);
            }

            var order = new TOrders
            {
                UserId = userId.Value,
                Name = idempotencyKey ?? $"Order-{Guid.NewGuid()}",
                Address = orderDto.Address,
                PostalCode = orderDto.PostalCode,
                CreatedAt = DateTime.UtcNow,
                OrderStatusId = 1,
                TotalAmount = totalAmount,
                TotalProfit = totalProfit
            };

            _context.TOrders.Add(order);
            await _context.SaveChangesAsync();

            foreach (var orderItem in orderItems)
            {
                orderItem.UserOrderId = order.Id;
            }

            _context.TOrderItems.AddRange(orderItems);
            _context.TProducts.UpdateRange(productUpdates);
            _context.TCartItems.RemoveRange(cart.CartItems);

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return CreatedAtAction(nameof(GetOrderById), new { id = order.Id }, order);
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            return StatusCode(500, "An error occurred while processing the checkout");
        }
    }

    [HttpPut("{id}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> PutTOrders(int id, UpdateOrderDto orderDto)
    {
        if (id <= 0)
            return BadRequest("Invalid order ID");

        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        var order = await _context.TOrders.FindAsync(id);
        if (order == null)
            return NotFound("Order not found");

        if (orderDto.OrderStatusId.HasValue)
        {
            var statusExists = await _context.TOrderStatus.AnyAsync(s => s.Id == orderDto.OrderStatusId.Value);
            if (!statusExists)
                return BadRequest("Invalid order status ID");
        }

        if (!string.IsNullOrWhiteSpace(orderDto.Name))
            order.Name = orderDto.Name;
        if (!string.IsNullOrWhiteSpace(orderDto.Address))
            order.Address = orderDto.Address;
        if (!string.IsNullOrWhiteSpace(orderDto.PostalCode))
            order.PostalCode = orderDto.PostalCode;
        if (orderDto.DeliveryDate.HasValue)
            order.DeliveryDate = orderDto.DeliveryDate;
        if (orderDto.OrderStatusId.HasValue)
            order.OrderStatusId = orderDto.OrderStatusId.Value;

        try
        {
            await _context.SaveChangesAsync();
            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!await TOrdersExistsAsync(id))
                return NotFound("Order not found");
            throw;
        }
        catch (Exception ex)
        {
            return StatusCode(500, "An error occurred while updating the order");
        }
    }

    [HttpPut("{id}/status")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> UpdateOrderStatus(int id, [FromBody] UpdateOrderStatusDto statusDto)
    {
        if (id <= 0)
            return BadRequest("Invalid order ID");

        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        var order = await _context.TOrders.FindAsync(id);
        if (order == null)
            return NotFound("Order not found");

        var statusExists = await _context.TOrderStatus.AnyAsync(s => s.Id == statusDto.OrderStatusId);
        if (!statusExists)
            return BadRequest("Invalid order status ID");

        order.OrderStatusId = statusDto.OrderStatusId;

        try
        {
            await _context.SaveChangesAsync();
            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!await TOrdersExistsAsync(id))
                return NotFound("Order not found");
            throw;
        }
        catch (Exception ex)
        {
            return StatusCode(500, "An error occurred while updating the order status");
        }
    }

    [HttpGet("statistics")]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<object>> GetOrderStatistics(
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null)
    {
        try
        {
            var query = _context.TOrders.AsQueryable();

            if (fromDate.HasValue)
                query = query.Where(o => o.CreatedAt >= fromDate.Value);

            if (toDate.HasValue)
                query = query.Where(o => o.CreatedAt <= toDate.Value);

            var statistics = await query
                .GroupBy(o => 1)
                .Select(g => new
                {
                    TotalOrders = g.Count(),
                    TotalRevenue = g.Sum(o => o.TotalAmount),
                    TotalProfit = g.Sum(o => o.TotalProfit),
                    AverageOrderValue = g.Average(o => (double)o.TotalAmount)
                })
                .FirstOrDefaultAsync();

            var statusStatistics = await _context.TOrders
                .Include(o => o.OrderStatus)
                .Where(o => !fromDate.HasValue || o.CreatedAt >= fromDate.Value)
                .Where(o => !toDate.HasValue || o.CreatedAt <= toDate.Value)
                .GroupBy(o => new { o.OrderStatusId, o.OrderStatus!.Name })
                .Select(g => new
                {
                    StatusId = g.Key.OrderStatusId,
                    StatusName = g.Key.Name,
                    Count = g.Count()
                })
                .ToListAsync();

            return Ok(new
            {
                GeneralStatistics = statistics ?? new
                {
                    TotalOrders = 0,
                    TotalRevenue = 0,
                    TotalProfit = 0,
                    AverageOrderValue = 0.0
                },
                StatusStatistics = statusStatistics
            });
        }
        catch (Exception ex)
        {
            return StatusCode(500, "An error occurred while retrieving statistics");
        }
    }

    [HttpDelete("{id}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> DeleteTOrders(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order ID");

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var order = await _context.TOrders
                .Include(o => o.OrderItems)
                    .ThenInclude(oi => oi.Product)
                .FirstOrDefaultAsync(o => o.Id == id);

            if (order == null)
                return NotFound("Order not found");

            foreach (var orderItem in order.OrderItems)
            {
                if (orderItem.Product != null)
                {
                    orderItem.Product.Count = (orderItem.Product.Count ?? 0) + orderItem.Quantity;
                }
            }

            _context.TOrderItems.RemoveRange(order.OrderItems);
            _context.TOrders.Remove(order);

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return NoContent();
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            return StatusCode(500, "An error occurred while deleting the order");
        }
    }

    [NonAction]
    private async Task<bool> TOrdersExistsAsync(int id)
    {
        return await _context.TOrders.AnyAsync(e => e.Id == id);
    }

    [NonAction]
    private int? GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        return int.TryParse(userIdClaim, out var userId) ? userId : null;
    }
}


namespace MainApi.Controllers.Order;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class OrderStatusController : ControllerBase
{
    private readonly MechanicContext _context;

    public OrderStatusController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<object>>> GetTOrderStatus()
    {
        var orderStatuses = await _context.TOrderStatus
            .Select(s => new
            {
                s.Id,
                s.Name,
                s.Icon,
                OrderCount = s.Orders != null ? s.Orders.Count() : 0
            })
            .ToListAsync();

        return Ok(orderStatuses);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<object>> GetTOrderStatus(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order status ID");

        var orderStatus = await _context.TOrderStatus
            .Include(s => s.Orders)
            .Select(s => new
            {
                s.Id,
                s.Name,
                s.Icon,
                OrderCount = s.Orders != null ? s.Orders.Count() : 0,
                Orders = s.Orders != null ? s.Orders.Select(o => new
                {
                    o.Id,
                    o.Name,
                    o.TotalAmount,
                    o.CreatedAt,
                    User = new
                    {
                        o.User.Id,
                        o.User.PhoneNumber,
                        o.User.FirstName,
                        o.User.LastName
                    }
                }).Cast<object>().ToList() : new List<object>()
            })
            .FirstOrDefaultAsync(s => s.Id == id);

        if (orderStatus == null)
            return NotFound();

        return Ok(orderStatus);
    }

    [HttpPost]
    public async Task<ActionResult<TOrderStatus>> PostTOrderStatus(CreateOrderStatusDto statusDto)
    {
        if (statusDto == null)
            return BadRequest("Order status data is required");

        if (string.IsNullOrWhiteSpace(statusDto.Name))
            return BadRequest("Name is required");

        var existingStatus = await _context.TOrderStatus
            .FirstOrDefaultAsync(s => s.Name.ToLower() == statusDto.Name.ToLower());

        if (existingStatus != null)
            return BadRequest("Order status with this name already exists");

        var orderStatus = new TOrderStatus
        {
            Name = statusDto.Name.Trim(),
            Icon = statusDto.Icon?.Trim()
        };

        _context.TOrderStatus.Add(orderStatus);
        await _context.SaveChangesAsync();

        return CreatedAtAction("GetTOrderStatus", new { id = orderStatus.Id }, orderStatus);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> PutTOrderStatus(int id, UpdateOrderStatusDto statusDto)
    {
        if (id <= 0)
            return BadRequest("Invalid order status ID");

        if (statusDto == null)
            return BadRequest("Order status data is required");

        var orderStatus = await _context.TOrderStatus.FindAsync(id);
        if (orderStatus == null)
            return NotFound();

        if (statusDto.Name != null)
        {
            if (string.IsNullOrWhiteSpace(statusDto.Name))
                return BadRequest("Name cannot be empty");

            var existingStatus = await _context.TOrderStatus
                .FirstOrDefaultAsync(s => s.Name.ToLower() == statusDto.Name.ToLower() && s.Id != id);

            if (existingStatus != null)
                return BadRequest("Order status with this name already exists");

            orderStatus.Name = statusDto.Name.Trim();
        }

        if (statusDto.Icon != null)
            orderStatus.Icon = statusDto.Icon.Trim();

        try
        {
            await _context.SaveChangesAsync();
            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!TOrderStatusExists(id))
                return NotFound();
            throw;
        }
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteTOrderStatus(int id)
    {
        if (id <= 0)
            return BadRequest("Invalid order status ID");

        var orderStatus = await _context.TOrderStatus.FindAsync(id);
        if (orderStatus == null)
            return NotFound();

        var hasOrders = await _context.TOrders.AnyAsync(o => o.OrderStatusId == id);
        if (hasOrders)
            return BadRequest("Cannot delete order status that is being used by orders");

        _context.TOrderStatus.Remove(orderStatus);
        await _context.SaveChangesAsync();

        return NoContent();
    }

    [NonAction]
    private bool TOrderStatusExists(int id)
    {
        return _context.TOrderStatus.Any(e => e.Id == id);
    }
}


namespace MainApi.Controllers.Product;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class ProductsController : ControllerBase
{
    private readonly MechanicContext _context;

    public ProductsController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    [AllowAnonymous]
    public async Task<ActionResult<object>> GetProducts([FromQuery] ProductSearchDto? search = null)
    {
        search ??= new ProductSearchDto();

        if (search.Page < 1) search.Page = 1;
        if (search.PageSize < 1) search.PageSize = 10;
        if (search.PageSize > 100) search.PageSize = 100;

        var query = _context.TProducts.Include(p => p.ProductType).AsQueryable();

        if (!string.IsNullOrWhiteSpace(search.Name))
        {
            query = query.Where(p => p.Name != null && p.Name.ToLower().Contains(search.Name.ToLower()));
        }

        if (search.ProductTypeId.HasValue)
        {
            query = query.Where(p => p.ProductTypeId == search.ProductTypeId);
        }

        if (search.MinPrice.HasValue)
        {
            query = query.Where(p => p.SellingPrice >= search.MinPrice);
        }

        if (search.MaxPrice.HasValue)
        {
            query = query.Where(p => p.SellingPrice <= search.MaxPrice);
        }

        if (search.InStock.HasValue)
        {
            if (search.InStock.Value)
                query = query.Where(p => p.Count > 0);
            else
                query = query.Where(p => p.Count == 0 || p.Count == null);
        }

        var totalItems = await query.CountAsync();
        var items = await query
            .OrderBy(p => p.Id)
            .Skip((search.Page - 1) * search.PageSize)
            .Take(search.PageSize)
            .Select(p => new
            {
                p.Id,
                p.Name,
                p.Icon,
                p.PurchasePrice,
                p.SellingPrice,
                p.Count,
                p.ProductTypeId,
                ProductType = p.ProductType != null ? new { p.ProductType.Id, p.ProductType.Name } : null,
            })
            .ToListAsync();

        var totalPages = totalItems == 0 ? 1 : (int)Math.Ceiling((double)totalItems / search.PageSize);

        return Ok(new
        {
            Items = items,
            TotalItems = totalItems,
            Page = search.Page,
            PageSize = search.PageSize,
            TotalPages = totalPages
        });
    }

    [HttpGet("low-stock")]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<IEnumerable<object>>> GetLowStockProducts([FromQuery] int threshold = 5)
    {
        if (threshold < 0) threshold = 5;

        var products = await _context.TProducts
            .Include(p => p.ProductType)
            .Where(p => p.Count.HasValue && p.Count <= threshold && p.Count > 0)
            .OrderBy(p => p.Count)
            .Select(p => new
            {
                p.Id,
                p.Name,
                p.Count,
                ProductType = p.ProductType != null ? p.ProductType.Name : null,
                p.SellingPrice
            })
            .ToListAsync();

        return Ok(products);
    }

    [HttpGet("statistics")]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<object>> GetProductStatistics()
    {
        var totalProducts = await _context.TProducts.CountAsync();

        var totalValue = await _context.TProducts
            .Where(p => p.Count.HasValue && p.PurchasePrice.HasValue && p.Count > 0)
            .SumAsync(p => (decimal)p.Count.Value * p.PurchasePrice.Value);

        var outOfStockCount = await _context.TProducts
            .CountAsync(p => !p.Count.HasValue || p.Count == 0);

        var lowStockCount = await _context.TProducts
            .CountAsync(p => p.Count.HasValue && p.Count <= 5 && p.Count > 0);

        return Ok(new
        {
            TotalProducts = totalProducts,
            TotalInventoryValue = (long)totalValue,
            OutOfStockProducts = outOfStockCount,
            LowStockProducts = lowStockCount
        });
    }

    [HttpGet("{id:int}")]
    [AllowAnonymous]
    public async Task<ActionResult<object>> GetProduct(int id)
    {
        if (id <= 0)
        {
            return BadRequest(new { Message = "Invalid product ID" });
        }

        var product = await _context.TProducts
            .Include(p => p.ProductType)
            .Where(p => p.Id == id)
            .Select(p => new
            {
                p.Id,
                p.Name,
                p.Icon,
                p.PurchasePrice,
                p.SellingPrice,
                p.Count,
                p.ProductTypeId,
                ProductType = p.ProductType != null ? new { p.ProductType.Id, p.ProductType.Name } : null,
            })
            .FirstOrDefaultAsync();

        if (product == null)
        {
            return NotFound(new { Message = $"Product with ID {id} not found" });
        }

        return Ok(product);
    }

    [HttpPut("{id:int}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> UpdateProduct(int id, [FromBody] ProductDto productDto)
    {
        if (id <= 0)
        {
            return BadRequest(new { Message = "Invalid product ID" });
        }

        if (productDto == null)
        {
            return BadRequest(new { Message = "Product data is required" });
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        var existingProduct = await _context.TProducts.FindAsync(id);
        if (existingProduct == null)
        {
            return NotFound(new { Message = $"Product with ID {id} not found" });
        }

        if (productDto.ProductTypeId.HasValue)
        {
            var productTypeExists = await _context.TProductTypes.AnyAsync(pt => pt.Id == productDto.ProductTypeId);
            if (!productTypeExists)
            {
                return BadRequest(new { Message = "Invalid ProductTypeId - Product type does not exist" });
            }
        }

        existingProduct.Name = productDto.Name?.Trim();
        existingProduct.Icon = productDto.Icon?.Trim();
        existingProduct.PurchasePrice = productDto.PurchasePrice;
        existingProduct.SellingPrice = productDto.SellingPrice;
        existingProduct.Count = productDto.Count;
        existingProduct.ProductTypeId = productDto.ProductTypeId;

        try
        {
            await _context.SaveChangesAsync();
            return Ok(new { Message = "Product updated successfully" });
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!await ProductExistsAsync(id))
            {
                return NotFound(new { Message = $"Product with ID {id} was deleted by another user" });
            }
            throw;
        }
    }

    [HttpPost]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<object>> CreateProduct([FromBody] ProductDto productDto)
    {
        if (productDto == null)
        {
            return BadRequest(new { Message = "Product data is required" });
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        if (productDto.ProductTypeId.HasValue)
        {
            var productTypeExists = await _context.TProductTypes.AnyAsync(pt => pt.Id == productDto.ProductTypeId);
            if (!productTypeExists)
            {
                return BadRequest(new { Message = "Invalid ProductTypeId - Product type does not exist" });
            }
        }

        var product = new TProducts
        {
            Name = productDto.Name?.Trim(),
            Icon = productDto.Icon?.Trim(),
            PurchasePrice = productDto.PurchasePrice,
            SellingPrice = productDto.SellingPrice,
            Count = productDto.Count ?? 0,
            ProductTypeId = productDto.ProductTypeId
        };

        _context.TProducts.Add(product);
        await _context.SaveChangesAsync();

        var result = new
        {
            product.Id,
            product.Name,
            product.Icon,
            product.PurchasePrice,
            product.SellingPrice,
            product.Count,
            product.ProductTypeId
        };

        return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, result);
    }

    [HttpPost("{id:int}/stock/add")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> AddStock(int id, [FromBody] ProductStockDto stockDto)
    {
        if (id <= 0)
            return BadRequest(new { Message = "Invalid product ID" });

        if (stockDto == null || !ModelState.IsValid)
            return BadRequest(new { Message = "Stock data is required and must be valid" });

        if (stockDto.Quantity <= 0)
            return BadRequest(new { Message = "Quantity must be greater than zero" });

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var product = await _context.TProducts.FindAsync(id);
            if (product == null)
                return NotFound(new { Message = $"Product with ID {id} not found" });

            var currentStock = product.Count ?? 0;
            if (currentStock > int.MaxValue - stockDto.Quantity)
                return BadRequest(new { Message = "Stock overflow - resulting quantity would be too large" });

            product.Count = currentStock + stockDto.Quantity;
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return Ok(new { Message = "Stock added successfully", NewCount = product.Count });
        }
        catch (Exception)
        {
            await transaction.RollbackAsync();
            return StatusCode(500, "An error occurred while adding stock.");
        }
    }

    [HttpPost("{id:int}/stock/remove")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> RemoveStock(int id, [FromBody] ProductStockDto stockDto)
    {
        if (id <= 0)
            return BadRequest(new { Message = "Invalid product ID" });

        if (stockDto == null || !ModelState.IsValid)
            return BadRequest(new { Message = "Stock data is required and must be valid" });

        if (stockDto.Quantity <= 0)
            return BadRequest(new { Message = "Quantity must be greater than zero" });

        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            var product = await _context.TProducts.FindAsync(id);
            if (product == null)
                return NotFound(new { Message = $"Product with ID {id} not found" });

            var currentStock = product.Count ?? 0;
            if (currentStock < stockDto.Quantity)
                return BadRequest(new { Message = $"Insufficient stock. Current stock: {currentStock}, Requested: {stockDto.Quantity}" });

            product.Count = currentStock - stockDto.Quantity;
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return Ok(new { Message = "Stock removed successfully", NewCount = product.Count });
        }
        catch (Exception)
        {
            await transaction.RollbackAsync();
            return StatusCode(500, "An error occurred while removing stock.");
        }
    }

    [HttpPost("bulk-update-prices")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> BulkUpdatePrices([FromBody] Dictionary<int, int> priceUpdates, [FromQuery] bool isPurchasePrice = false)
    {
        if (priceUpdates == null || !priceUpdates.Any())
        {
            return BadRequest(new { Message = "Price updates data is required" });
        }

        var invalidPrices = priceUpdates.Where(p => p.Value < 0).ToList();
        if (invalidPrices.Any())
        {
            return BadRequest(new { Message = "Prices cannot be negative" });
        }

        var productIds = priceUpdates.Keys.ToList();
        var products = await _context.TProducts
            .Where(p => productIds.Contains(p.Id))
            .ToListAsync();

        if (!products.Any())
        {
            return NotFound(new { Message = "No products found with the provided IDs" });
        }

        var updatedCount = 0;
        foreach (var product in products)
        {
            if (priceUpdates.ContainsKey(product.Id))
            {
                if (isPurchasePrice)
                    product.PurchasePrice = priceUpdates[product.Id];
                else
                    product.SellingPrice = priceUpdates[product.Id];
                updatedCount++;
            }
        }

        await _context.SaveChangesAsync();
        return Ok(new { Message = $"{updatedCount} products updated successfully" });
    }

    [HttpDelete("{id:int}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> DeleteProduct(int id)
    {
        if (id <= 0)
        {
            return BadRequest(new { Message = "Invalid product ID" });
        }

        var product = await _context.TProducts
            .Include(p => p.OrderDetails)
            .FirstOrDefaultAsync(p => p.Id == id);

        if (product == null)
        {
            return NotFound(new { Message = $"Product with ID {id} not found" });
        }

        if (product.OrderDetails?.Any() == true)
        {
            return BadRequest(new { Message = "Cannot delete product that has order history. Consider deactivating instead." });
        }

        _context.TProducts.Remove(product);
        await _context.SaveChangesAsync();

        return Ok(new { Message = "Product deleted successfully" });
    }

    [NonAction]
    private async Task<bool> ProductExistsAsync(int id)
    {
        return await _context.TProducts.AnyAsync(e => e.Id == id);
    }
}


namespace MainApi.Controllers.Product;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class ProductTypesController : ControllerBase
{
    private readonly MechanicContext _context;

    public ProductTypesController(MechanicContext context)
    {
        _context = context;
    }

    [HttpGet]
    [AllowAnonymous]
    public async Task<ActionResult<IEnumerable<object>>> GetProductTypes([FromQuery] string? search = null, [FromQuery] int page = 1, [FromQuery] int pageSize = 10)
    {
        if (page < 1) page = 1;
        if (pageSize < 1 || pageSize > 100) pageSize = 10;

        try
        {
            var query = _context.TProductTypes.Include(pt => pt.Products).AsQueryable();

            if (!string.IsNullOrWhiteSpace(search))
            {
                query = query.Where(pt => pt.Name != null && pt.Name.ToLower().Contains(search.ToLower()));
            }

            var totalCount = await query.CountAsync();
            var productTypes = await query
                .Select(pt => new
                {
                    pt.Id,
                    pt.Name,
                    pt.Icon,
                    ProductCount = pt.Products != null ? pt.Products.Count : 0,
                    TotalValue = pt.Products != null ? pt.Products.Sum(p => (p.Count ?? 0) * (p.PurchasePrice ?? 0)) : 0,
                    InStockProducts = pt.Products != null ? pt.Products.Count(p => (p.Count ?? 0) > 0) : 0
                })
                .OrderBy(pt => pt.Name)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            var response = new
            {
                Data = productTypes,
                TotalCount = totalCount,
                Page = page,
                PageSize = pageSize,
                TotalPages = (int)Math.Ceiling((double)totalCount / pageSize)
            };

            return Ok(response);
        }
        catch (Exception ex)
        {
            return StatusCode(500, "خطا در دریافت انواع محصولات");
        }
    }

    [HttpGet("{id}")]
    [AllowAnonymous]
    public async Task<ActionResult<object>> GetProductType(int id)
    {
        try
        {
            if (id <= 0)
            {
                return BadRequest("شناسه نامعتبر است");
            }

            var productType = await _context.TProductTypes
                .Include(pt => pt.Products)
                .Where(pt => pt.Id == id)
                .Select(pt => new
                {
                    pt.Id,
                    pt.Name,
                    pt.Icon,
                    Products = pt.Products != null ? pt.Products.Select(p => new
                    {
                        p.Id,
                        p.Name,
                        p.Count,
                        p.SellingPrice,
                        p.PurchasePrice,
                        p.Icon,
                        IsInStock = (p.Count ?? 0) > 0
                    }).OrderBy(p => p.Name).ToList() : null,
                    ProductCount = pt.Products != null ? pt.Products.Count : 0,
                    InStockProducts = pt.Products != null ? pt.Products.Count(p => (p.Count ?? 0) > 0) : 0,
                    TotalValue = pt.Products != null ? pt.Products.Sum(p => (p.Count ?? 0) * (p.PurchasePrice ?? 0)) : 0,
                    TotalSellingValue = pt.Products != null ? pt.Products.Sum(p => (p.Count ?? 0) * (p.SellingPrice ?? 0)) : 0
                })
                .FirstOrDefaultAsync();

            if (productType == null)
            {
                return NotFound("نوع محصول یافت نشد");
            }

            return Ok(productType);
        }
        catch (Exception ex)
        {
            return StatusCode(500, "خطا در دریافت نوع محصول");
        }
    }

    [HttpPut("{id}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> UpdateProductType(int id, ProductTypeDto productTypeDto)
    {
        try
        {
            if (id <= 0 || id != productTypeDto.Id)
            {
                return BadRequest("شناسه نامعتبر است");
            }

            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            if (string.IsNullOrWhiteSpace(productTypeDto.Name))
            {
                return BadRequest("نام نوع محصول الزامی است");
            }

            var existingProductType = await _context.TProductTypes.FindAsync(id);
            if (existingProductType == null)
            {
                return NotFound("نوع محصول یافت نشد");
            }

            var duplicateExists = await _context.TProductTypes
                .AnyAsync(pt => pt.Name != null && pt.Name.ToLower() == productTypeDto.Name.ToLower() && pt.Id != id);
            if (duplicateExists)
            {
                return BadRequest("نوع محصولی با این نام قبلاً وجود دارد");
            }

            existingProductType.Name = productTypeDto.Name.Trim();
            existingProductType.Icon = string.IsNullOrWhiteSpace(productTypeDto.Icon) ? null : productTypeDto.Icon.Trim();

            await _context.SaveChangesAsync();

            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!await ProductTypeExistsAsync(id))
            {
                return NotFound("نوع محصول یافت نشد");
            }
            return Conflict("تضاد در به‌روزرسانی داده‌ها");
        }
        catch (Exception ex)
        {
            return StatusCode(500, "خطا در به‌روزرسانی نوع محصول");
        }
    }

    [HttpPost]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<TProductTypes>> CreateProductType(ProductTypeDto productTypeDto)
    {
        try
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            if (string.IsNullOrWhiteSpace(productTypeDto.Name))
            {
                return BadRequest("نام نوع محصول الزامی است");
            }

            var duplicateExists = await _context.TProductTypes
                .AnyAsync(pt => pt.Name != null && pt.Name.ToLower() == productTypeDto.Name.ToLower());
            if (duplicateExists)
            {
                return BadRequest("نوع محصولی با این نام قبلاً وجود دارد");
            }

            var productType = new TProductTypes
            {
                Name = productTypeDto.Name.Trim(),
                Icon = string.IsNullOrWhiteSpace(productTypeDto.Icon) ? null : productTypeDto.Icon.Trim()
            };

            _context.TProductTypes.Add(productType);
            await _context.SaveChangesAsync();

            var result = new
            {
                productType.Id,
                productType.Name,
                productType.Icon
            };

            return CreatedAtAction("GetProductType", new { id = productType.Id }, result);
        }
        catch (Exception ex)
        {
            return StatusCode(500, "خطا در ایجاد نوع محصول");
        }
    }

    [HttpDelete("{id}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> DeleteProductType(int id)
    {
        try
        {
            if (id <= 0)
            {
                return BadRequest("شناسه نامعتبر است");
            }

            var productType = await _context.TProductTypes
                .Include(pt => pt.Products)
                .FirstOrDefaultAsync(pt => pt.Id == id);

            if (productType == null)
            {
                return NotFound("نوع محصول یافت نشد");
            }

            if (productType.Products?.Any() == true)
            {
                return BadRequest("امکان حذف نوع محصولی که دارای محصول وابسته است وجود ندارد");
            }

            _context.TProductTypes.Remove(productType);
            await _context.SaveChangesAsync();

            return NoContent();
        }
        catch (Exception ex)
        {
            return StatusCode(500, "خطا در حذف نوع محصول");
        }
    }

    [NonAction]
    private async Task<bool> ProductTypeExistsAsync(int id)
    {
        return await _context.TProductTypes.AnyAsync(e => e.Id == id);
    }
}


namespace MainApi.Controllers.User;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class UsersController : ControllerBase
{
    private readonly MechanicContext _context;
    private readonly IConfiguration _configuration;
    private readonly ILogger<UsersController> _logger;

    public UsersController(MechanicContext context, IConfiguration configuration, ILogger<UsersController> logger)
    {
        _context = context;
        _configuration = configuration;
        _logger = logger;
    }

    [HttpGet]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<IEnumerable<UserProfileDto>>> GetUsers()
    {
        try
        {
            var users = await _context.TUsers
                .Where(u => u.IsActive)
                .Select(u => new UserProfileDto
                {
                    Id = u.Id,
                    PhoneNumber = u.PhoneNumber,
                    CreatedAt = u.CreatedAt
                })
                .ToListAsync();

            return Ok(users);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving users");
            return StatusCode(500, "An error occurred while retrieving users");
        }
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<UserProfileDto>> GetUser(int id)
    {
        try
        {
            var user = await _context.TUsers
                .Where(u => u.Id == id && u.IsActive)
                .Select(u => new UserProfileDto
                {
                    Id = u.Id,
                    PhoneNumber = u.PhoneNumber,
                    CreatedAt = u.CreatedAt
                })
                .FirstOrDefaultAsync();

            if (user == null)
                return NotFound();

            return Ok(user);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving user {UserId}", id);
            return StatusCode(500, "An error occurred while retrieving user");
        }
    }

    [HttpGet("profile")]
    public async Task<ActionResult<UserProfileDto>> GetProfile()
    {
        try
        {
            var userId = GetCurrentUserId();
            if (userId == null)
                return Unauthorized();

            var user = await _context.TUsers
                .Where(u => u.Id == userId && u.IsActive)
                .Select(u => new UserProfileDto
                {
                    Id = u.Id,
                    PhoneNumber = u.PhoneNumber,
                    CreatedAt = u.CreatedAt
                })
                .FirstOrDefaultAsync();

            if (user == null)
                return NotFound();

            return Ok(user);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving user profile");
            return StatusCode(500, "An error occurred while retrieving profile");
        }
    }

    [HttpPost]
    [Authorize(Roles = "Admin")]
    public async Task<ActionResult<UserProfileDto>> CreateUser([FromBody] TUsers tUsers)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        if (string.IsNullOrWhiteSpace(tUsers.PhoneNumber))
            return BadRequest("Phone number is required.");

        try
        {
            if (await _context.TUsers.AnyAsync(u => u.PhoneNumber == tUsers.PhoneNumber))
                return Conflict("User with this phone number already exists.");

            tUsers.CreatedAt = DateTime.UtcNow;
            tUsers.IsActive = true;

            _context.TUsers.Add(tUsers);
            await _context.SaveChangesAsync();

            var dto = new UserProfileDto
            {
                Id = tUsers.Id,
                PhoneNumber = tUsers.PhoneNumber,
                CreatedAt = tUsers.CreatedAt
            };

            return CreatedAtAction(nameof(GetUser), new { id = dto.Id }, dto);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating user");
            return StatusCode(500, "An error occurred while creating user");
        }
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateUser(int id, [FromBody] TUsers updateRequest)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        try
        {
            var currentUserId = GetCurrentUserId();
            if (currentUserId != id && !User.IsInRole("Admin"))
                return Forbid();

            var existingUser = await _context.TUsers.FindAsync(id);
            if (existingUser == null || !existingUser.IsActive)
                return NotFound();

            existingUser.FirstName = updateRequest.FirstName;
            existingUser.LastName = updateRequest.LastName;

            _context.Entry(existingUser).State = EntityState.Modified;
            await _context.SaveChangesAsync();

            return NoContent();
        }
        catch (DbUpdateConcurrencyException ex)
        {
            _logger.LogError(ex, "Concurrency error updating user {UserId}", id);
            if (!await _context.TUsers.AnyAsync(u => u.Id == id))
                return NotFound();
            return Conflict("User was modified by another process");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating user {UserId}", id);
            return StatusCode(500, "An error occurred while updating user");
        }
    }

    [HttpPatch("{id}/status")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> ChangeUserStatus(int id, [FromBody] bool isActive)
    {
        try
        {
            var user = await _context.TUsers.FindAsync(id);
            if (user == null)
                return NotFound();

            user.IsActive = isActive;
            await _context.SaveChangesAsync();

            return NoContent();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error changing user status {UserId}", id);
            return StatusCode(500, "An error occurred while changing user status");
        }
    }

    [HttpDelete("{id}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> DeleteUser(int id)
    {
        try
        {
            var user = await _context.TUsers.FindAsync(id);
            if (user == null)
                return NotFound();

            user.IsActive = false;
            await _context.SaveChangesAsync();

            return NoContent();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting user {UserId}", id);
            return StatusCode(500, "An error occurred while deleting user");
        }
    }

    [HttpPost("login")]
    [AllowAnonymous]
    public async Task<IActionResult> Login([FromBody] LoginRequestDto request)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        var clientIp = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";
        var rateLimitKey = $"login_{clientIp}_{request.PhoneNumber}";

        if (await IsRateLimited(rateLimitKey))
        {
            _logger.LogWarning("Rate limit exceeded for login attempt from IP: {ClientIP}, Phone: {PhoneNumber}", clientIp, request.PhoneNumber);
            return BadRequest("Too many login attempts. Please try again later.");
        }

        try
        {
            var user = await _context.TUsers.FirstOrDefaultAsync(u => u.PhoneNumber == request.PhoneNumber);

            if (user == null)
            {
                user = new TUsers
                {
                    PhoneNumber = request.PhoneNumber,
                    CreatedAt = DateTime.UtcNow,
                    IsActive = true,
                    IsAdmin = false
                };
                _context.TUsers.Add(user);
                await _context.SaveChangesAsync();
                _logger.LogInformation("New user created with phone: {PhoneNumber}", request.PhoneNumber);
            }

            if (!user.IsActive)
            {
                _logger.LogWarning("Login attempt for inactive user: {PhoneNumber}", request.PhoneNumber);
                return Unauthorized("Account is inactive.");
            }

            await RemoveExpiredOtps(user.Id);

            var activeOtpExists = await _context.TUserOtps.AnyAsync(o => o.UserId == user.Id && !o.IsUsed && o.ExpiresAt > DateTime.UtcNow);

            if (activeOtpExists)
                return BadRequest("An active OTP already exists. Please wait before requesting a new one.");

            var otp = GenerateSecureOtp();

            var userOtp = new TUserOtp
            {
                UserId = user.Id,
                OtpHash = BCrypt.Net.BCrypt.HashPassword(otp),
                ExpiresAt = DateTime.UtcNow.AddMinutes(5),
                CreatedAt = DateTime.UtcNow,
                IsUsed = false,
                AttemptCount = 0
            };

            _context.TUserOtps.Add(userOtp);
            await _context.SaveChangesAsync();

            var apiKey = _configuration["Kavenegar:ApiKey"];
            var template = "verify";

            if (string.IsNullOrEmpty(apiKey))
                throw new InvalidOperationException("SMS service is not configured.");

            var api = new KavenegarApi(apiKey);
            await Task.Run(() => api.VerifyLookup(request.PhoneNumber, otp, template));

            _logger.LogInformation("OTP sent successfully to phone: {PhoneNumber}", request.PhoneNumber);
            return Ok(new { Message = "OTP sent successfully" });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during login process for phone: {PhoneNumber}", request.PhoneNumber);
            return StatusCode(500, "Failed to send SMS verification code.");
        }
    }

    [HttpPost("verify-otp")]
    [AllowAnonymous]
    public async Task<ActionResult<AuthResponseDto>> VerifyOtp([FromBody] VerifyOtpRequestDto request)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        var clientIp = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";
        var rateLimitKey = $"otp_{clientIp}_{request.PhoneNumber}";

        if (await IsRateLimited(rateLimitKey))
            return BadRequest("Too many verification attempts. Please try again later.");

        var user = await _context.TUsers.FirstOrDefaultAsync(u => u.PhoneNumber == request.PhoneNumber && u.IsActive);
        if (user == null)
            return BadRequest("Invalid credentials.");

        var storedOtp = await _context.TUserOtps
            .Where(o => o.UserId == user.Id && !o.IsUsed && o.ExpiresAt > DateTime.UtcNow)
            .OrderByDescending(o => o.CreatedAt)
            .FirstOrDefaultAsync();

        if (storedOtp == null)
            return BadRequest("Invalid or expired OTP code.");

        if (storedOtp.AttemptCount >= 3)
        {
            storedOtp.IsUsed = true;
            await _context.SaveChangesAsync();
            return BadRequest("Too many failed attempts. Please request a new OTP.");
        }

        if (!BCrypt.Net.BCrypt.Verify(request.Code, storedOtp.OtpHash))
        {
            storedOtp.AttemptCount++;
            await _context.SaveChangesAsync();
            return BadRequest("Invalid OTP code.");
        }

        storedOtp.IsUsed = true;
        await _context.SaveChangesAsync();

        await RevokeUserRefreshTokens(user.Id);

        var token = GenerateJwtToken(user);
        var refreshTokenValue = GenerateSecureToken();

        var userAgent = Request.Headers.UserAgent.ToString();
        var safeUserAgent = string.IsNullOrEmpty(userAgent) ? "unknown" : userAgent.Length > 500 ? userAgent[..500] : userAgent;

        var refreshToken = new TRefreshToken
        {
            UserId = user.Id,
            TokenHash = BCrypt.Net.BCrypt.HashPassword(refreshTokenValue),
            ExpiresAt = DateTime.UtcNow.AddDays(7),
            CreatedAt = DateTime.UtcNow,
            CreatedByIp = clientIp,
            UserAgent = safeUserAgent
        };

        _context.TRefreshToken.Add(refreshToken);
        await _context.SaveChangesAsync();

        return Ok(new AuthResponseDto
        {
            Token = token,
            User = new UserProfileDto
            {
                Id = user.Id,
                PhoneNumber = user.PhoneNumber,
                CreatedAt = user.CreatedAt
            },
            ExpiresAt = DateTime.UtcNow.AddHours(1),
            RefreshToken = refreshTokenValue
        });
    }

    [HttpPost("refresh")]
    [AllowAnonymous]
    public async Task<IActionResult> RefreshToken([FromBody] RefreshRequestDto request)
    {
        var storedTokens = _context.TRefreshToken
            .Include(x => x.User)
            .Where(x => x.ExpiresAt > DateTime.UtcNow && x.RevokedAt == null)
            .AsEnumerable()
            .Where(x => BCrypt.Net.BCrypt.Verify(request.RefreshToken, x.TokenHash))
            .ToList();

        var storedToken = storedTokens.FirstOrDefault();

        if (storedToken == null || storedToken.User == null || !storedToken.User.IsActive)
            return Unauthorized(new { message = "توکن معتبر نیست یا منقضی شده است" });

        storedToken.RevokedAt = DateTime.UtcNow;

        var newJwt = GenerateJwtToken(storedToken.User);
        var newRefreshValue = GenerateSecureToken();

        var userAgent = Request.Headers.UserAgent.ToString();
        var safeUserAgent = string.IsNullOrEmpty(userAgent) ? "unknown" : userAgent.Length > 500 ? userAgent[..500] : userAgent;

        var newRefresh = new TRefreshToken
        {
            UserId = storedToken.UserId,
            TokenHash = BCrypt.Net.BCrypt.HashPassword(newRefreshValue),
            CreatedAt = DateTime.UtcNow,
            ExpiresAt = DateTime.UtcNow.AddDays(7),
            CreatedByIp = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
            UserAgent = safeUserAgent
        };

        _context.TRefreshToken.Add(newRefresh);
        await _context.SaveChangesAsync();

        return Ok(new
        {
            token = newJwt,
            refreshToken = newRefreshValue
        });
    }

    [HttpPost("logout")]
    public async Task<IActionResult> Logout([FromBody] RefreshRequestDto request)
    {
        if (string.IsNullOrWhiteSpace(request.RefreshToken))
            return BadRequest(new { message = "Refresh token is required" });

        var query = _context.TRefreshToken
            .Where(x => x.RevokedAt == null && x.ExpiresAt > DateTime.UtcNow)
            .AsEnumerable()
            .Where(x => BCrypt.Net.BCrypt.Verify(request.RefreshToken, x.TokenHash));

        var tokenList = query.ToList();

        if (!tokenList.Any())
            return NotFound(new { message = "توکن یافت نشد" });

        foreach (var token in tokenList)
            token.RevokedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        return Ok(new { message = "خروج با موفقیت انجام شد" });
    }

    [NonAction]
    private async Task<bool> IsRateLimited(string key, int maxAttempts = 5, int windowMinutes = 15)
    {
        var now = DateTime.UtcNow;
        var entry = await _context.TRateLimit.FirstOrDefaultAsync(r => r.Key == key);

        if (entry == null)
        {
            await _context.TRateLimit.AddAsync(new TRateLimit
            {
                Key = key,
                Count = 1,
                ResetAt = now.AddMinutes(windowMinutes),
                UpdatedAt = now
            });
            await _context.SaveChangesAsync();
            return false;
        }

        if (entry.ResetAt < now)
        {
            await _context.TRateLimit
                .Where(r => r.Key == key)
                .ExecuteUpdateAsync(setters => setters
                    .SetProperty(r => r.Count, 1)
                    .SetProperty(r => r.ResetAt, now.AddMinutes(windowMinutes))
                    .SetProperty(r => r.UpdatedAt, now));
            return false;
        }

        if (entry.Count >= maxAttempts)
            return true;

        await _context.TRateLimit
            .Where(r => r.Key == key)
            .ExecuteUpdateAsync(setters => setters
                .SetProperty(r => r.Count, entry.Count + 1)
                .SetProperty(r => r.UpdatedAt, now));

        return false;
    }

    [NonAction]
    public async Task RemoveExpiredOtps(int userId)
    {
        var query = _context.TUserOtps
            .Where(o => o.UserId == userId && (o.ExpiresAt <= DateTime.UtcNow || o.IsUsed));

        await query.ExecuteDeleteAsync();
    }

    [NonAction]
    public async Task RevokeUserRefreshTokens(int userId)
    {
        var query = _context.TRefreshToken
            .Where(rt => rt.UserId == userId && rt.RevokedAt == null && rt.ExpiresAt > DateTime.UtcNow);

        await query.ExecuteUpdateAsync(setters => setters.SetProperty(rt => rt.RevokedAt, DateTime.UtcNow));
    }

    [NonAction]
    private string GenerateSecureOtp()
    {
        using var rng = RandomNumberGenerator.Create();
        var bytes = new byte[4];
        rng.GetBytes(bytes);
        var value = Math.Abs(BitConverter.ToInt32(bytes, 0)) % 9000 + 1000;
        return value.ToString();
    }

    [NonAction]
    private string GenerateSecureToken()
    {
        using var rng = RandomNumberGenerator.Create();
        var bytes = new byte[32];
        rng.GetBytes(bytes);
        return Convert.ToBase64String(bytes);
    }
    
    [NonAction]
    private string GenerateJwtToken(TUsers user)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]);

        var claims = new List<Claim>
    {
        new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
        new Claim(JwtRegisteredClaimNames.UniqueName, user.PhoneNumber),
        new Claim("isAdmin", user.IsAdmin.ToString())
    };

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddHours(1),
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature),
            Audience = _configuration["Jwt:Audience"],
            Issuer = _configuration["Jwt:Issuer"]
        };

        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }

    [NonAction]
    private int GetCurrentUserId()
    {
        var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier) ?? User.FindFirst(JwtRegisteredClaimNames.Sub);
        if (userIdClaim == null)
            throw new UnauthorizedAccessException("کاربر احراز هویت نشده است");
        return int.Parse(userIdClaim.Value);
    }
}


namespace MainApi.Services;

public class RateLimitService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly int _maxAttempts = 5;
    private readonly TimeSpan _window = TimeSpan.FromMinutes(2);

    public RateLimitService(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    public async Task<bool> IsLimitedAsync(string phoneNumber)
    {
        using var scope = _scopeFactory.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<MechanicContext>();

        var rate = await context.TRateLimits.FirstOrDefaultAsync(x => x.PhoneNumber == phoneNumber);
        if (rate == null) return false;

        if (DateTime.UtcNow - rate.LastAttempt > _window)
        {
            rate.Attempts = 0;
            await context.SaveChangesAsync();
            return false;
        }

        return rate.Attempts >= _maxAttempts;
    }

    public async Task RegisterAttemptAsync(string phoneNumber)
    {
        using var scope = _scopeFactory.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<MechanicContext>();

        var rate = await context.TRateLimits.FirstOrDefaultAsync(x => x.PhoneNumber == phoneNumber);

        if (rate == null)
        {
            rate = new TRateLimits
            {
                PhoneNumber = phoneNumber,
                Attempts = 1,
                LastAttempt = DateTime.UtcNow
            };
            context.TRateLimits.Add(rate);
        }
        else
        {
            if (DateTime.UtcNow - rate.LastAttempt > _window)
                rate.Attempts = 1;
            else
                rate.Attempts++;

            rate.LastAttempt = DateTime.UtcNow;
        }

        await context.SaveChangesAsync();
    }
}